「状態（State）をどこに定義すべきか？」の判断基準を、今回の **Model - Controller - View (UI)** アーキテクチャに基づいて整理しました。

迷ったときはこの表と基準を見返してください。

---

### 🏛️ 状態定義場所の決定版ガイド

| 状態の種類 | 定義する場所 | 役割 (Role) | 具体例 |
| --- | --- | --- | --- |
| **1. サーバー状態**<br>

<br>(Server State) | **Model**<br>

<br>(API Hooks) | **「真実」の管理**<br>

<br>DBにあるデータそのもの。 | ・食事リストデータ<br>

<br>・ユーザープロフィール<br>

<br>・APIのLoading/Error |
| **2. 画面の状態**<br>

<br>(Screen State) | **Controller**<br>

<br>(Custom Hook) | **「操作」の管理**<br>

<br>ユーザーが今何をしているか。<br>

<br>アプリの振る舞い。 | ・モーダルの開閉 (`isOpen`)<br>

<br>・編集中のデータ (`editingItem`)<br>

<br>・選択中のタブ |
| **3. ローカルUI状態**<br>

<br>(UI State) | **UI Component**<br>

<br>(Presentational) | **「演出」の管理**<br>

<br>見た目だけの一時的なもの。<br>

<br>他には影響しない。 | ・アコーディオンの開閉<br>

<br>・ホバー状態<br>

<br>・アニメーションの発火 |

---

### 🧠 3つの階層の詳細解説

#### 1. Model層（倉庫番）

* **場所:** `useTodayPageModel.ts`, `useQuery`
* **ルール:** 「リロードしたらサーバーから取り直すもの」はここ。
* **コード:**
```typescript
// Model
const mealItemsQuery = useQuery(...); // サーバー状態

```



#### 2. Controller層（司令塔）★今回はここが重要

* **場所:** `useTodayPageController.ts`
* **ルール:** 「複数のUIパーツに影響するもの」や「ビジネスロジックに必要なもの」はここ。
* **コード:**
```typescript
// Controller
const [isModalOpen, setIsModalOpen] = useState(false); // 画面の状態
const [selectedId, setSelectedId] = useState<string>(null);

```



#### 3. UI層（現場担当）

* **場所:** `NutrientProgressSection.tsx` などの `.tsx`
* **ルール:** 「親やControllerに教える必要がない些細なこと」はここ。
* **コード:**
```tsx
// UI Component
const [isMenuOpen, setIsMenuOpen] = useState(false); // ローカルUI状態
// ※これはControllerに持っていかなくてOK

```



---

### 🚦 判断のための「3つの質問」

状態を定義する前に、以下の順で自問すると迷いません。

1. **Q1: それはデータベースに保存されている？**
* YES → **Model** (React Queryへ)
* NO → 次へ


2. **Q2: それが変わると、他のコンポーネントやデータ保存処理に影響する？**
* YES → **Controller** (`useTodayPageController`へ)
* *例: 「編集ボタン」を押すと「モーダル」が開く → 2つが連動するのでController*


3. **Q3: それは、その部品の中だけで完結する見た目の話？**
* YES → **UI Component** (そのファイル内の `useState`へ)
* *例: 詳細を見るための「もっと見る」ボタン*



---

### 📂 ファイル構成とのマッピング

今回のリファクタリング後のファイル構成で言うと、以下のようになります。

```text
src/features/today/
├── model/
│   └── useTodayPageModel.ts      ⬅️ [1. サーバー状態] (DBデータ)
├── hooks/
│   └── useTodayPageController.ts ⬅️ [2. 画面の状態] (モーダル開閉など)
└── ui/
    ├── TodayPageContent.tsx      ⬅️ 状態を持たない (注入される場所)
    └── NutrientProgressSection.tsx ⬅️ [3. ローカルUI状態] (アコーディオン等)

```

この分類で管理すれば、コードが増えても「どこを見ればいいか」が一目瞭然になります。

UI要素（プレゼンテーションコンポーネント）に注入するPropsは、大きく分けて**「データ（材料）」**と**「関数（リモコン）」**の2種類だけです。

この2つさえ渡せば、UIは「表示」と「ユーザー操作の伝達」という仕事を完璧にこなせます。

---

### 📦 UIに注入する「2つの要素」

| 種類 | 英語名 | 役割 | 具体例 (Props名) |
| --- | --- | --- | --- |
| **1. データ** | **Data / Values** | **「何を表示するか」**<br>

<br>画面に描画される情報そのもの。 | `mealItems` (リスト)<br>

<br>`isOpen` (開閉状態)<br>

<br>`isLoading` (読込中か)<br>

<br>`activeTarget` (目標値) |
| **2. 関数** | **Handlers / Actions** | **「操作されたら何をするか」**<br>

<br>ボタンクリックや送信時の合図。 | `onClick`<br>

<br>`onClose`<br>

<br>`onSubmit`<br>

<br>`onRetry` |

---

### 🧩 具体的なイメージ（パペット人形の例）

UIコンポーネントは **「パペット（操り人形）」** だと思ってください。
注入するPropsは、その人形を動かすための **「糸」** です。

* **データの糸:** 人形の「服」や「持ち物」を変える（見た目を変える）。
* **関数の糸:** 人形の手足を引っ張って「動き」を親に伝える。

---

### 💻 コードでの実例

あなたの `NutrientProgressSection` を例に見てみましょう。

```tsx
// 🟢 Controller (親: useTodayPageController)
// ここで「材料」と「リモコン」を用意する
const { nutrientProgress, isError } = model; // データ
const handleRetry = () => model.refetch();   // 関数

// ↓ 注入 (Inject) ↓

// 🟡 View (子: NutrientProgressSection)
<NutrientProgressSection
  // 1. データ (Data) を注入
  nutrientProgress={nutrientProgress}  // 表示する数値
  isError={isError}                    // エラーが出ているか
  hasTarget={!!activeTarget}           // 目標設定があるか

  // 2. 関数 (Handler) を注入
  onRetry={handleRetry}                // ボタンが押されたら呼ぶやつ
/>

```

### 🚫 注入してはいけないもの（アンチパターン）

逆に、以下のような「ロジックそのもの」は注入してはいけません。

1. **`fetch` や `axios` などの通信処理**
* ❌ `fetchData={() => fetch('/api/...')}`
* UIが通信の詳細を知ってはいけません。


2. **複雑な計算ロジック**
* ❌ `calculateCalories={(items) => items.reduce(...)}`
* 計算済みの結果（数値）を渡すか、計算ロジックを隠蔽した関数を渡すべきです。


3. **巨大なオブジェクトそのまま**
* 🔺 `model={wholeModelObject}`
* 可能な限り、必要なデータだけを分解して渡す（Destructuring）方が、依存関係が明確になります。



### まとめ

UI要素に対してPropsとして注入するのは：

1. **今の状態（データ）**：「今はロード中だよ」「リストの中身はこれだよ」
2. **親への合図（関数）**：「保存ボタンが押されたよ」「閉じるボタンが押されたよ」

この2つだけです。「どうやって保存するか（通信）」や「どうやって計算するか」は注入しません。UIは**「結果を受け取り、合図を送る」**だけの存在にします。