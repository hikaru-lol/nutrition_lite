いいですね、じゃあ auth だけにフォーカスして、プロフィールと同じノリで

ざっくり仕様
外部仕様（API / UX）
内部仕様（ドメイン / UseCase / Repo / セキュリティ）
を整理していきます 💪

Auth 機能の仕様 0. 概要
目的

ユーザーのアカウント管理（登録 / 認証 / 退会）
セッション管理（JWT + HttpOnly Cookie）
プラン情報（TRIAL / FREE / PAID）と試用期間の管理の「入口」
Auth 自体は「ログインできる状態」を作るのが責務で、
課金やプラン遷移の詳細は Billing モジュールと連携する前提。

1. Auth のデータ仕様（ドメイン）
   1-1. User エンティティ
   ※ 型はイメージ。実際はすでにある User 定義に合わせる前提。

User(
id: UserId, # UUID 文字列の VO
email: EmailAddress,
hashed_password: HashedPassword,
name: str,
plan: UserPlan, # TRIAL / FREE / PAID
trial_info: TrialInfo, # trial_ends_at を含む
has_profile: bool, # プロフィールを作成済みか
created_at: datetime,
deleted_at: datetime | None,
)
1-2. 値オブジェクト / Enum
UserId（str ラッパ）

空文字は不可
EmailAddress

メール形式バリデーション
不正なら InvalidEmailFormatError
HashedPassword

生パスワードではなく、「ハッシュ済みであること」を意味する VO
UserPlan: StrEnum

TRIAL = "trial"
FREE = "free"
PAID = "paid"
TrialInfo

trial_ends_at: datetime | None
is_trial_active: bool（now < trial_ends_at なら True）
1-3. ドメイン上の制約
email は全ユーザーで一意（ユニーク制約）

deleted_at is not None なユーザーは ログイン不可

新規ユーザーは必ず UserPlan = TRIAL + trial_ends_at = created_at + 7 日

trial_ends_at を超えたら、

Billing 側の状態に応じて FREE or PAID に切り替え 2. 外部仕様（API / UX 視点）
2-1. 利用者と前提
操作主体：未ログインユーザー（Register/Login）、ログイン済みユーザー（Me/Logout/Delete）

セッションは「JWT + HttpOnly Cookie」で管理：

ACCESS_TOKEN（短命、例：15〜30 分）
REFRESH_TOKEN（長め、例：7〜30 日）
Cookie 設定例：

HttpOnly = True
Secure = 本番のみ True
SameSite = "lax" or "none"（設定で切り替え）
2-2. エンドポイント一覧（外部仕様）
(1) POST /auth/register
目的：新規ユーザー登録 + ログイン状態にする
リクエストボディ例：
{
"email": "user@example.com",
"password": "PlainPassword123",
"name": "Hikaru"
}
振る舞い：

email フォーマットチェック

email 重複チェック（既に存在 → 409 / EmailAlreadyUsedError）

パスワードハッシュ

User 作成：

plan = TRIAL
trial_ends_at = now + 7 days
has_profile = false
ACCESS_TOKEN / REFRESH_TOKEN を発行し、HttpOnly Cookie にセット

レスポンス：

201 Created + シンプルなユーザー情報（id, email, plan, trial_ends_at など）
(2) POST /auth/login
目的：既存ユーザーのログイン
リクエスト：
{
"email": "user@example.com",
"password": "PlainPassword123"
}
振る舞い：

email でユーザー取得（なければ 401）
パスワード検証（不一致なら 401）
deleted_at が設定されていれば 401
ACCESS_TOKEN / REFRESH_TOKEN を再発行し Cookie にセット
レスポンス：

200 OK + 現在のユーザー情報（plan, trial_ends_at, has_profile など）
(3) POST /auth/refresh
目的：Refresh Token から新しい Access Token を取得

入力：

Cookie の REFRESH_TOKEN（ヘッダには何も不要）
振る舞い：

REFRESH_TOKEN を検証（署名・期限・形式）
トークン内の user_id を元にユーザー取得
deleted_at がある場合は 401
新しい ACCESS_TOKEN（必要なら REFRESH_TOKEN も）を発行し Cookie 再セット
レスポンス：

200 OK + {"ok": true} 的な軽い情報、もしくは現在ユーザー情報
(4) POST /auth/logout
目的：ログアウト（クライアントセッションの終了）

入力：

Cookie（ACCESS_TOKEN / REFRESH_TOKEN）
振る舞い：

両方の Cookie を「無効値 + 即時 expire」で上書き
サーバー側で Refresh Token の失効を管理する場合はここで無効化登録
レスポンス：

204 No Content
(5) GET /auth/me
目的：現在ログイン中のユーザー情報を取得

認証：

ACCESS_TOKEN Cookie を使用。
無効・期限切れ → 401。
レスポンス例：

{
"id": "user-uuid",
"email": "user@example.com",
"name": "Hikaru",
"plan": "trial",
"trial_ends_at": "2025-01-10T12:34:56Z",
"has_profile": true
}
(6) DELETE /auth/me
目的：アカウント削除（退会）

認証：

ログイン済み
振る舞い：

User の deleted_at をセット（ソフトデリート）
関連データは即時削除 or 後続ジョブで削除（方針次第）
Cookie の ACCESS/REFRESH を失効
レスポンス：

204 No Content
2-3. プラン・試用期間の外部的ふるまい
/auth/me で返す情報に：

plan
trial_ends_at
is_trial_active（あっても良い）
フロント側はこの情報を使って：

「残り何日 TRIAL か」
「TRIAL 終了後は課金 or FREE になるか」
などを表示。
課金に関する実際の購読状態・Stripe ID などは Billing モジュール側 で持つ
（auth は「論理プラン値」のみ管理）。

3. 内部仕様（ドメイン / UseCase / Repo / セキュリティ）
   3-1. Domain: User とエラー
   User エンティティは前述のフィールドをもつ。

主なドメインエラー：

InvalidEmailFormatError
EmailAlreadyUsedError
InvalidUserPlanError（必要なら）
3-2. Application Ports
UserRepositoryPort
class UserRepositoryPort(Protocol):
def get_by_email(self, email: EmailAddress) -> User | None: ...
def get_by_id(self, user_id: UserId) -> User | None: ...
def save(self, user: User) -> None: ...
PasswordHasherPort
class PasswordHasherPort(Protocol):
def hash(self, raw_password: str) -> HashedPassword: ...
def verify(self, raw_password: str, hashed: HashedPassword) -> bool: ...
TokenServicePort
class TokenServicePort(Protocol):
def create_access_token(self, payload: TokenPayload) -> str: ...
def create_refresh_token(self, payload: TokenPayload) -> str: ...
def verify_refresh_token(self, token: str) -> TokenPayload: ...
TokenPayload：

user_id: str
plan: str など（最低限 user_id）
ClockPort
class ClockPort(Protocol):
def now(self) -> datetime: ...
3-3. UseCase 一覧
RegisterUserUseCase
LoginUserUseCase
RefreshTokenUseCase
LogoutUserUseCase
GetCurrentUserUseCase（/auth/me 用）
DeleteUserUseCase（/auth/me DELETE）
3-4. 各 UseCase の内部仕様（ざっくり）
RegisterUserUseCase
入力：email, password, name

流れ：

EmailAddress VO 生成（フォーマットチェック）
UserRepository で get_by_email → 既に存在すれば EmailAlreadyUsedError
PasswordHasher でハッシュ生成
UserPlan.TRIAL + TrialInfo(trial_ends_at = clock.now() + 7 日) で User 作成
Repo.save
TokenService で ACCESS / REFRESH 作成（payload に user_id 等）
DTO 経由でユーザー情報とトークン（または Cookie セットを API 層に委譲）を返す
LoginUserUseCase
入力：email, password

流れ：

EmailAddress からユーザー検索
ユーザーなし or deleted_at あり → 認証失敗
PasswordHasher.verify で検証
TokenService で ACCESS / REFRESH 再発行
ユーザー情報とトークン情報を DTO で返す
RefreshTokenUseCase
入力：refresh_token

流れ：

TokenService.verify_refresh_token → TokenPayload 取得
添付された user_id をもとに UserRepo からユーザー取得
deleted_at があれば 401
TokenService.create_access_token で新しい ACCESS_TOKEN を発行
必要なら REFRESH_TOKEN もローテーション（セキュリティポリシー次第）
LogoutUserUseCase
入力：user_id（実質使わないことも多い）

流れ：

基本的には Stateless なので、サーバー側では特に何もしない
Blacklist やセッションレコードがある場合はそこで無効化
API 層に「Cookie クリアしてね」というシグナルを返す程度
GetCurrentUserUseCase
入力：user_id（ACCESS_TOKEN から抽出）

流れ：

UserRepo.get_by_id
ユーザーが存在し、deleted_at がないことを確認
ユーザー情報を DTO で返す
DeleteUserUseCase
入力：user_id

流れ：

UserRepo.get_by_id

見つからなければ 404 or 無視（ポリシー次第）

deleted_at = now でソフトデリート

関連データ削除は：

すぐに消す or 別ジョブで削除（後で設計）
3-5. セキュリティ仕様（最低限）
パスワードは必ずハッシュ化（bcrypt 等）

JWT 署名には十分な長さのランダムシークレットキー（環境変数から）

Cookie 設定：

本番：

Secure = True
SameSite = "none" or "lax"（フロントとの構成による）
開発：

Secure = False
SameSite = "lax"
トークンの有効期限：

ACCESS_TOKEN：短め（15〜30 分）
REFRESH_TOKEN：長め（7〜30 日）
重要：

課金・プランチェックは auth ではなく「アプリケーション層の UC 側」で行う
（例：栄養計算の UC が「このユーザーの plan が TRIAL/PAID か？」をチェック） 4. まとめ（Auth の仕様のポイント）
外部仕様（ユーザー視点）

email + password + name で登録 → 7 日間の TRIAL 開始 → 即ログイン状態
ログイン・ログアウト・セッション継続（Refresh）・退会ができる
/auth/me で自分のプランや試用期間の情報が取れる
内部仕様（システム視点）

Domain: User / UserPlan / TrialInfo / EmailAddress / UserId で「ユーザーと状態」を表現
Application: Register / Login / Refresh / Logout / Me / Delete の UC が責務を明確化
Infra: UserRepository / PasswordHasher / TokenService / Clock の実装を DI で差し込む
Billing と連動するのは「プランの更新」だけで、
Auth 自体は「誰がどのプランでログインしているか」を表現するモジュール
こんな形で Auth の仕様を固めておけば、
このあと Billing や「プラン別制限」「栄養計算 UC のガードロジック」を乗せていくときもズレずに進められるはずです 💡

いいですね、ここまでで「毎日のパイプライン」の主要なピースが揃ってきたので、
それらを裏で回す JOB（自動処理） の仕様を整理していきます 💪

これまでと同じく：

概要
JOB ごとの要件・振る舞い
外部仕様（いつ・誰が・どう動くか）
内部仕様（UseCase / ポート / 設計）
の順でまとめます。

JOB（自動処理）の仕様 0. 概要
目的

アプリのコアとなる「毎日のサイクル」を、ユーザー操作だけに依存せず、
日付の切り替わり / 一日のタイミング に合わせて自動で整えていく。

現時点で想定している JOB は大きく 2 つ：

ターゲットスナップショット JOB
→ 日付を跨いだタイミングで「昨日のターゲット」を固定化する。

提案生成 JOB（Recommendation JOB）
→ 毎日一定時刻に「直近 5 日分レポートが揃っているユーザー」に対して自動で提案を生成する。

（将来的には、バッジ付与・古いデータのクリーンアップなども JOB 候補）

1. JOB 一覧と要件
   1-1. ターゲットスナップショット JOB
   名前（仮）： SnapshotActiveTargetForYesterdayJob

目的

「過去日のターゲット値を固定化」するために、
毎日 1 回、日付を跨ぐタイミングで 昨日の日付 の DailyTargetSnapshot を作成する。
要件

実行タイミング：

毎日 深夜〜早朝（例：00:05〜01:00 頃）の 1 回
対象：

アクティブユーザー全員（退会済みを除く）
やること（論理）：

システム時間から「今日（today）」を取得

yesterday = today - 1 日

全アクティブユーザーを取得

各ユーザーについて：

EnsureDailyTargetSnapshotUseCase.execute(user_id, yesterday) を呼ぶ

既に Snapshot があればそのまま
なければ、その時点の Active Target から DailyTargetSnapshot を生成・保存
Active Target が存在しないユーザーはスキップ（ログだけ出す）

結果

(user_id, date=yesterday) に対して必ず 0 or 1 の Snapshot が存在し、
一度作成された Snapshot は過去日のターゲットとして固定される。
1-2. 提案生成 JOB（Recommendation JOB）
名前（仮）： GenerateDailyMealRecommendationsJob

目的

毎日定時に、直近 5 日分の DailyNutritionReport が揃っているユーザーに対して、
「今日の提案」(MealRecommendation) を自動で生成する。
要件

実行タイミング：

毎日 朝〜昼前（例：07:00）に 1 回
対象：

アクティブユーザーのうち、UserPlan が TRIAL または PAID のユーザー
前提：

直近 5 日分の日次レポート DailyNutritionReport が存在するユーザーのみ。
やること（論理）：

システム時間から「今日（today）」を取得 → base_date = today

全アクティブユーザー一覧を取得

各ユーザーについて：

プランチェック：plan in {TRIAL, PAID} でない場合 → スキップ

GenerateMealRecommendationUseCase.execute(user_id, base_date) を呼ぶ

直近 5 日のレポート数が不足 → NotEnoughDailyReportsError → スキップ（ログのみ）
generated_for_date=base_date の Recommendation が既に存在 → MealRecommendationAlreadyExistsError → スキップ
それ以外のエラー → ログ出力（他ユーザー処理は続行）
正常に生成できた場合、そのユーザーには「今日の提案」が 1 件保存される。

結果

毎日、レポートが溜まっているユーザーには自動的に「今日の提案」が作られ、
ユーザーはアプリを開くだけで提案が見られる。 2. 外部仕様（どこからどう動くか）
2-1. スケジューリング（誰が呼ぶか）
JOB 自体は、アプリ内部のコードとして app/jobs/ 配下に実装される。

実際の起動は以下いずれか：

OS cron（コンテナ内 or ホスト）
CI/CD（GitHub Actions のスケジュール）
クラウド側のスケジューラ（AWS EventBridge / CloudWatch Events など）
例：

# 毎日 00:10 にターゲットスナップショット JOB

python -m app.jobs.snapshot_active_target_for_yesterday

# 毎日 07:00 に提案生成 JOB

python -m app.jobs.generate_meal_recommendations
2-2. ユーザーから見た挙動
ユーザーは直接 JOB を意識しない。
ただし以下のような UX として「結果」を感じる：
ターゲットスナップショット JOB

昨日以前の日付については、ターゲット値が「その当時のもの」で一貫している。
ターゲット定義を変えても、過去のレポートや評価が変な風に変わらない。
提案生成 JOB

朝アプリを開くと「今日の提案」がすでに存在する。
自分で提案ボタンを押さなくても、習慣化しやすい。 3. 内部仕様（UseCase / Repo / jobs/ 構成）
3-1. UseCase レイヤ（アプリケーション）
EnsureDailyTargetSnapshotUseCase（既に整理済）
責務：

(user_id, date) について DailyTargetSnapshot を「必ず用意する」。

既にあればそれを返す。
なければ Active Target をもとに新規作成 → 保存 → 返す。
JOB からの使い方：

ターゲットスナップショット JOB は、ユーザーごとにこれを呼ぶことで実装される。
GenerateMealRecommendationUseCase（既に整理済）
責務：

(user_id, base_date) について、必要条件を満たす場合に MealRecommendation を生成。
JOB からの使い方：

提案生成 JOB は、ユーザーごとに execute(user_id, base_date=today) を呼ぶ形で実行する。
3-2. JOB 実装（app/jobs/）
3-2-1. ターゲットスナップショット JOB
パス例： app/jobs/snapshot_active_target_for_yesterday.py

論理コードイメージ：

def run_snapshot_active_target_for_yesterday_job() -> None:
today = clock.now().date()
yesterday = today - timedelta(days=1)

    users = user_repo.list_active_users()

    for user in users:
        try:
            ensure_daily_snapshot_uc.execute(user_id=user.id, date_=yesterday)
            log_ok(...)
        except ActiveTargetNotFoundError:
            log_skip_no_active_target(...)
        except Exception as e:
            log_error(...)

user_repo.list_active_users()：退会していないユーザー全員。
ensure_daily_snapshot_uc：EnsureDailyTargetSnapshotUseCase の DI。
3-2-2. 提案生成 JOB
パス例： app/jobs/generate_meal_recommendations.py

論理コードイメージ：

def run_generate_meal_recommendations_job() -> None:
today = clock.now().date()
users = user_repo.list_active_users()

    for user in users:
        try:
            # プランがFREEならスキップ（UC内でチェックしてもよい）
            if user.plan not in (UserPlan.TRIAL, UserPlan.PAID):
                log_skip_free_plan(...)
                continue

            recommendation = generate_reco_uc.execute(
                user_id=user.id,
                base_date=today,
            )
            log_ok(...)

        except NotEnoughDailyReportsError:
            log_skip_not_enough_reports(...)
        except MealRecommendationAlreadyExistsError:
            log_skip_already_exists(...)
        except Exception as e:
            log_error(...)

generate_reco_uc：GenerateMealRecommendationUseCase の DI。
エラーはロギングしつつ、他のユーザー処理は継続する。
3-3. DI / コンテナとの関係
app/di/container.py にそれぞれの UC を組み立てるファクトリを用意：

get_ensure_daily_target_snapshot_use_case()
get_generate_meal_recommendation_use_case()
JOB スクリプトは基本的に：

session = get*session()
user_repo = SqlAlchemyUserRepository(session)
各 UC = get*...( )
clock = get_clock()
を組み立てて実行する。 4. 将来的な拡張候補（メモ）
※今すぐ実装ではなく、「JOB レイヤに載せられると良いもの」の候補：

バッジ付与 JOB

毎日、各ユーザーの「記録完了状態」を集計して、
達成条件を満たしたバッジを自動付与する。
古いデータのクリーンアップ JOB

deleted_at が一定期間前の FoodEntry や Session レコードを削除する。
集計・分析用スナップショット JOB

週次 / 月次の栄養サマリを別テーブルに積んでおくなど。 5. まとめ（JOB 仕様のキモ）
ターゲットスナップショット JOB

過去日のターゲット値を「当時のアクティブターゲット」で固定化するための JOB。
毎日 1 回、昨日の日付に対して Snapshot を作る。
提案生成 JOB

直近 5 日レポートが揃っている TRIAL/PAID ユーザーに対して、
毎日自動で「今日の提案」を生成するための JOB。
設計上のポイント

どちらの JOB も「アプリケーション層の UC を呼び出すだけ」にすることで、
手動トリガー（API）とロジックを共有できるようにしておく。
失敗はログとして残しつつ、他ユーザーへの処理は継続する ベストエフォート型 の設計。
この仕様をベースに、app/jobs/ の各スクリプトと di/container.py の DI を整えていけば、
「人が何もしなくても毎日適切にスナップショットと提案が用意される」状態を作れるはずです 💡

いいですね、じゃあターゲットだけピックアップして、
プロフィール/Auth と同じノリで 仕様をガッチリ固めていきます 💪

ターゲット機能の仕様 0. 概要
目的

ユーザーごとの「1 日あたりの栄養目標（17 栄養素など）」を定義・管理する。
当日は “今のアクティブターゲット” を使う。
過去日は “その日当時のアクティブターゲットを固定化したスナップショット” を使う。
これにより、

日々の栄養評価（実績 vs ターゲット）
日次レポート / 提案 / バッジ など
の 基準値 を提供するのがターゲット機能の役割。

1. データ仕様（ドメイン）
   1-1. TargetDefinition（ターゲット定義）
   1 ユーザーあたり最大 5 件まで。常に 1 件だけがアクティブ。

主なフィールド（イメージ）
TargetDefinition(
id: TargetId,
user_id: UserId,

    name: str,              # 「減量用」「筋トレ期間用」などの名前
    goal_type: GoalType,    # lose_weight / maintain / gain_muscle etc.
    activity_level: ActivityLevel,  # low / medium / high

    nutrients: list[TargetNutrient],  # 17栄養素分の目標値

    is_active: bool,        # このターゲットがアクティブか
    created_at: datetime,
    updated_at: datetime,

)
TargetNutrient:

code: NutrientCode（例: energy, protein, fat, carb, vitamin_c …）
amount: NutrientAmount（value + unit）
source: NutrientSource（例: "llm", "manual"）
制約
1 ユーザーにつき TargetDefinition は 最大 5 件。

1 ユーザーにつき is_active == True は 常に 1 件。

新規作成時：

上限未満（5 件未満）の場合のみ作成可
「新規をアクティブにする」場合、既存のアクティブを非アクティブにする必要がある。
nutrients は必ず「アプリで扱う 17 栄養素ぶん」が入っている想定
（不足や重複がある場合は UC 側かドメイン側で補正/エラー）

1-2. DailyTargetSnapshot（日次ターゲットスナップショット）
「ある日付にとってのターゲット値を固定化したもの」。

DailyTargetSnapshot(
id: DailyTargetSnapshotId,
user_id: UserId,
date: date, # この日付のためのスナップショット

    base_target_id: TargetId,         # スナップショット化した元の TargetDefinition の ID
    nutrients: list[TargetNutrient],  # その時点のターゲット値

    created_at: datetime,

)
制約
(user_id, date) に対して 最大 1 件。
一度作られた Snapshot の nutrients は 変更不可（immutable）。
Snapshot は基本的に JOB からのみ作成（ユーザーが直接いじらない）。
1-3. LLM 関連 VO / Enum
GoalType：lose_weight, maintain, gain_muscle, recovery …（用途に応じて拡張）

ActivityLevel：low, medium, high

NutrientCode：energy, protein, fat, carb, fiber, vitamin_c, … など 17 栄養素

NutrientAmount：

value: float
unit: str（例 "kcal", "g", "mg", "µg"）
NutrientSource：

"llm"：LLM による自動生成
"manual"：ユーザーによる手動変更 2. 外部仕様（UX / API 視点）
2-1. 利用者と前提
操作主体：ログイン済みユーザー。

認可：

自分のターゲットのみ操作可能。
他ユーザーのターゲットにはアクセス不可。
2-2. ユースケース（UX レベル）
初回セットアップ

プロフィール（性別/身長/体重/meals_per_day）を入力。
「目標（減量・維持・増量など）」と「活動レベル」を選択。
→ LLM によって 1 つ目のターゲット定義が生成され、アクティブとして設定される。
ターゲットを追加で作成

既にターゲットがある状態で、新しい目標パターンを登録したい。
LLM による「別パターンのターゲット」を追加（最大 5 件まで）。
必要に応じて、新しいターゲットをアクティブに切り替える。
ターゲットの部分変更（手動）

すでに生成されたターゲットの栄養値を少し調整したい。
例：たんぱく質 +10g, カロリー -200kcal など。
この変更は 手動編集のみ有効。LLM による差分更新は行わない。
アクティブターゲットの切り替え

ターゲット一覧から別のターゲットをアクティブにする。
「減量フェーズ → 維持フェーズ」などの切り替え。
ターゲット一覧・詳細の参照

UI 上で、自分のターゲット一覧を閲覧。
それぞれの名前, 目標, 活動レベル, 栄養一覧を表示。
過去日のターゲット参照

日次レポートやグラフ画面で「その日のターゲット値」を見たい。
過去日は DailyTargetSnapshot から読み出す。
2-3. API 仕様（外部インターフェース）
(1) GET /targets
目的：ユーザーのターゲット定義一覧を取得。
レスポンス例：
{
"items": [
{
"id": "target-uuid-1",
"name": "減量期（春）",
"goal_type": "lose_weight",
"activity_level": "medium",
"is_active": true,
"created_at": "2025-01-10T12:00:00Z",
"nutrients": [
{ "code": "energy", "value": 1800, "unit": "kcal" },
{ "code": "protein", "value": 120, "unit": "g" },
...
]
},
...
]
}
(2) GET /targets/active
目的：現在のアクティブターゲットを取得。
レスポンス：上記アイテムのうち 1 件（is_active == true）。
(3) POST /targets（LLM による新規作成）
目的：新しい TargetDefinition を LLM で生成。

制約：

既に 5 件ある場合 → 400 or 409（上限超過エラー）。
リクエスト例：

{
"name": "増量期（冬）",
"goal_type": "gain_muscle",
"activity_level": "high"
}
フロー：

Profile 取得（なければエラー）
既存ターゲット数チェック（5 件以上ならエラー）
LLM に Profile + goal_type + activity_level を渡して栄養ターゲット生成
TargetDefinition として保存
オプション：activate=true が指定されていれば、アクティブに切り替え
レスポンス：

作成されたターゲット定義（+ アクティブかどうか）
(4) PATCH /targets/{target_id}（手動の部分変更）
目的：既存ターゲットの栄養値を手動で微調整。

前提：

LLM を使わず、ユーザー入力値をそのまま反映。
リクエスト例：

{
"nutrients": [
{ "code": "protein", "value": 130, "unit": "g" },
{ "code": "energy", "value": 1900, "unit": "kcal" }
]
}
振る舞い：

指定された栄養素コードの値のみ上書き。
LLM 由来かどうかに関係なく source = "manual" として扱うことも可能。
(5) POST /targets/{target_id}/activate
目的：指定ターゲットをアクティブにする。

振る舞い：

そのユーザーの他のターゲット is_active をすべて False にする。
指定 target_id のターゲットのみ is_active = True にする。
(6) 過去日のターゲットの参照
基本的には 内部仕様で Snapshot を使って計算する想定なので、
外部 API として必須ではないが、将来用に：

GET /targets/daily?date=YYYY-MM-DD

当日 → Active Target に基づく値
過去日 → Snapshot の nutrients
を返す API を用意することも可能。

3. 内部仕様（ドメイン / UseCase / Repo / JOB）
   3-1. ドメイン層（app/domain/target）
   TargetDefinition

TargetNutrient

DailyTargetSnapshot

ValueObjects:

GoalType, ActivityLevel, NutrientCode, NutrientAmount, NutrientSource
エラー：

TargetNotFoundError
ActiveTargetNotFoundError
TargetLimitExceededError（5 件超過）
NoActiveTargetForSnapshotError（JOB 実行時など）
ドメインレベルの不変条件（Invariants）：

1 ユーザーあたり TargetDefinition は 5 件まで
→ それ以上は作れない。
1 ユーザーあたり is*active=True は常に 1 件（または 0 件は許容するかどうかを決める）。
DailyTargetSnapshot の nutrients は生成後変更しない（immutable）。
3-2. Application Ports
TargetRepositoryPort
class TargetRepositoryPort(Protocol):
def list_by_user(self, user_id: UserId) -> list[TargetDefinition]: ...
def get_by_id(self, target_id: TargetId) -> TargetDefinition | None: ...
def get_active_for_user(self, user_id: UserId) -> TargetDefinition | None: ...
def save(self, target: TargetDefinition) -> None: ...
DailyTargetSnapshotRepositoryPort
class DailyTargetSnapshotRepositoryPort(Protocol):
def get_by_user_and_date(self, user_id: UserId, date*: date) -> DailyTargetSnapshot | None: ...
def save(self, snapshot: DailyTargetSnapshot) -> None: ...
TargetGeneratorPort（LLM 用）
class TargetGeneratorPort(Protocol):
def generate(
self,
profile: Profile,
goal_type: GoalType,
activity_level: ActivityLevel,
) -> list[TargetNutrient]:
...
3-3. UseCase 一覧（アプリケーション層）
CreateTargetUseCase（LLM 新規生成）
ListTargetsUseCase
GetTargetUseCase
UpdateTargetUseCase（手動部分変更）
ActivateTargetUseCase（アクティブ切り替え）
EnsureDailyTargetSnapshotUseCase（「ある日に対して Snapshot を必ず用意する」）
SnapshotActiveTargetForYesterdayJobUseCase（JOB 内部で使う、よりバッチ寄り）
3-4. 各 UseCase の仕様（ざっくり）
CreateTargetUseCase
入力：goal_type, activity_level, name（任意）

処理：

Profile 取得（なければエラー）
既存ターゲット数チェック（5 件以上 → TargetLimitExceededError）
TargetGeneratorPort で nutrients を生成
TargetDefinition を作成・保存
オプションでアクティブ化（引数で指定）
UpdateTargetUseCase（手動部分変更）
入力：target_id, nutrients の変更内容

処理：

target を取得（なければエラー）
指定された nutrient code の amount を上書き
source = "manual" をセットするかはポリシー次第
保存
ActivateTargetUseCase
入力：target_id

処理：

target を取得（なければエラー）
同ユーザーの他ターゲットの is_active = False に変更
指定ターゲット is_active = True に変更
保存
EnsureDailyTargetSnapshotUseCase
入力：user_id, date

処理：

SnapshotRepo で既に (user_id, date) があるか確認 → あればそれを返す

なければ TargetRepositoryPort.get_active_for_user で Active Target を取得

なければ ActiveTargetNotFoundError
Active Target から DailyTargetSnapshot を生成

保存して返す

SnapshotActiveTargetForYesterdayJobUseCase（JOB 用）
入力：date_today（ジョブ実行時の「今日」）

処理：

date_yesterday = date_today - 1 日

全アクティブユーザー一覧を取得（UserRepositoryPort）

各ユーザーについて：

EnsureDailyTargetSnapshotUseCase.execute(user, date_yesterday) を呼ぶ
（Active がない場合はエラー or ログしてスキップ） 4. まとめ（ターゲット仕様のキモ）
TargetDefinition
→ 「今後どういう栄養を目指すか」のパターンを最大 5 件まで持てる。
→ 新規の作成は LLM で、部分変更は手動のみ。

Active Target
→ 「今日のターゲット」は常にこの 1 つから参照。

DailyTargetSnapshot
→ 「昨日以前」のターゲット値は、その当時の Active Target を固定化したもの。
→ 日を跨ぐ JOB で自動生成し、後から変えない。

他機能（栄養計算 / レポート / 提案）
→ 対象日のターゲット参照ロジックは一貫して：

過去日 → DailyTargetSnapshot
当日 → Active Target
という形で、ターゲット機能が「栄養評価の基準レイヤー」を提供するようになっています 💡

この仕様を前提に、次は「記録完了判定」や「日次レポート」「提案」をさらに同じノリで掘っていく、という流れで進められます。

了解！じゃあまずは プロフィール機能だけにフォーカスして、

もともとの仕様

外部仕様（API／UX 視点）

内部仕様（ドメイン／UseCase／Repo 視点）

をまとめていきます 💪

プロフィール機能の仕様 0. 概要
目的
ユーザーの基本情報（性別・身長・体重など）と、
アプリ動作の前提となる meals_per_day（1 日のメイン食事回数）を管理する。

この情報は以下に利用される：

ターゲット生成（LLM による 1 日分の栄養目標）

記録完了判定（DailyLogCompletion）

日次レポート・提案の前提情報

将来的なバッジ・分析など

1. プロフィールのデータ仕様
   1-1. 項目
   （ドメイン的な「意味」と「型」の定義）

項目 型 必須 説明
user_id UserId (str UUID) Yes このプロフィールの所有者
sex enum (male / female / other / unspecified) No 性別
birthdate date No 生年月日
height_cm float No 身長（cm）
weight_kg float No 体重（kg）
meals_per_day int Yes 1 日のメイン食事回数（1 以上）
image_id `str	None` No
created_at datetime Yes 作成日時
updated_at datetime Yes 更新日時
Repo 実装
SqlAlchemyProfileRepository(ProfileRepositoryPort)：

get_by_user_id：

user_id でフィルタ → Entity に変換

save：

既存モデルの有無をチェック → insert / update

画像ストレージ
ProfileImageStoragePort：

save(file: bytes) -> image_id: str

get_url(image_id: str) -> str

MinIO 実装 or ローカルストレージ実装

3-4. 他コンテキストとの関係
DailyLogCompletionUseCase：

ProfileRepo から Profile を取得 → meals_per_day がない/おかしい場合はエラー

GenerateDailyNutritionReportUseCase：

レポート生成前に Profile を取得し、LLM 入力に渡す

GenerateMealRecommendationUseCase：

提案生成時にも Profile を取得し、LLM 入力に渡す

4. まとめ（プロフィール機能の仕様のポイント）
   外部仕様（ユーザー視点）

自分のプロフィールを登録・更新・取得できる

meals_per_day を必ず設定する（記録完了・レポート・提案に必要）

プロフィール画像も設定可能

プロフィールがないと、栄養計算 / レポート / 提案は利用不可

内部仕様（システム視点）

Domain: Profile エンティティが「意味と制約」を持つ中心体

Application: Get / Upsert / UpdateImage の UseCase を通して操作

Infra: SQLAlchemy モデル + Repository + 画像ストレージアダプタ

他機能は ProfileRepositoryPort 経由で Profile を読み取り、
存在しない場合は明示的なエラーとして扱う

こんな感じでプロフィールを一段深く具体化しました。
次は同じノリで「ターゲット」「記録完了」「日次レポート」「提案」みたいに機能ごとに掘っていけますが、
どれからやりたいか順番決めちゃっても OK です（ターゲット or 記録完了あたりからが相性良さそう）。

いいですね、栄養計算のところをちゃんと固めておくと、このアプリの「コアの動き」がかなりクリアになります 💪

ここでは 「栄養計算」＝ 1 食分の推定（Meal）＋ 1 日分の合計（Daily）」 に分けて、

概要
外部仕様（API/UX）
内部仕様（ドメイン / UseCase / ポート）
の順で整理していきます。

栄養計算機能の仕様 0. 概要
目的

食事記録（FoodEntry）を元に、

1 食分ごとの栄養（MealNutritionSummary）
1 日分の栄養合計（DailyNutritionSummary）
を算出・保存する。
位置づけ

食事記録 → 栄養計算 → 記録完了判定 → 日次レポート → 提案
というパイプラインの 2 段目〜3 段目の中核。
プラン制約

「栄養計算」は TRIAL / PAID ユーザーのみ利用可能。

FREE ユーザー：

FoodEntry の記録はできるが、栄養計算（推定・合計）は利用不可（エラー返却）。

1. データ仕様（ドメイン視点）
   1-1. MealNutritionSummary（1 食分）
   キー:
   (user_id, date, meal_type, meal_index) で 0 or 1 件。

MealNutritionSummary(
id: MealNutritionSummaryId,
user_id: UserId,
date: date,
meal_type: MealType, # "main" or "snack"
meal_index: int | None, # main: 1..N, snack: None

    nutrients: list[MealNutrientIntake],
    generated_at: datetime,

)
MealNutrientIntake:
MealNutrientIntake(
code: NutrientCode, # 例: "energy", "protein", ...
amount: NutrientAmount, # value + unit
source: NutrientSource, # "llm", "db", "stub" など
)
1-2. DailyNutritionSummary（1 日分）
キー:
(user_id, date) で 0 or 1 件。

DailyNutritionSummary(
id: DailyNutritionSummaryId,
user_id: UserId,
date: date,

    nutrients: list[DailyNutrientIntake],
    generated_at: datetime,

)
DailyNutrientIntake は Meal とほぼ同じ構造（用途上の名称違い）。
1-3. Nutrient 関連 VO / エラー
NutrientCode: 定義済み 17 栄養素（energy, protein, fat, carb, …）

NutrientAmount: value: float, unit: str

NutrientSource: "llm", "manual", "aggregated" など

主なエラー：

NutritionEstimationFailedError（Estimator での致命的エラー）
MealNutritionNotFoundError（必要な Meal サマリがない場合など、必要なら） 2. 外部仕様（API / UX 視点）
※ ここは「ユーザー／フロントからどう見えるか」のレベル。

2-1. 利用者と前提
操作主体：ログイン済みユーザー

前提：

FoodEntry が登録されていること
プロフィールが存在し、meals_per_day が設定済みであること
プランが TRIAL / PAID であること（FREE は利用不可）
2-2. 1 食分＋ 1 日分の評価 API（例）
（今まで話してきた /nutrition/meal イメージ）

POST /nutrition/meal
目的：
特定の 1 食分について栄養計算を行い、同時にその日の Daily も更新した上で、
「その食事の栄養」と「その日の合計」を返す。

認証：必須

プラン条件：TRIAL / PAID のみ許可（FREE → 403 or 402）

リクエスト例：

{
"date": "2025-11-30",
"meal_type": "main",
"meal_index": 1
}
処理イメージ：

プランチェック（TRIAL / PAID 以外 → エラー）
(user_id, date, meal_type, meal_index) に紐づく FoodEntry 一覧取得
ComputeMealNutritionUseCase で MealNutritionSummary を推定＆保存
ComputeDailyNutritionSummaryUseCase で DailyNutritionSummary を再計算＆保存
両方をレスポンスとして返す
レスポンス例（ざっくり）：

{
"meal": {
"date": "2025-11-30",
"meal_type": "main",
"meal_index": 1,
"nutrients": [
{ "code": "energy", "value": 550, "unit": "kcal" },
{ "code": "protein", "value": 35, "unit": "g" },
...
]
},
"daily": {
"date": "2025-11-30",
"nutrients": [
{ "code": "energy", "value": 1600, "unit": "kcal" },
{ "code": "protein", "value": 80, "unit": "g" },
...
]
}
}
2-3. 1 日分だけ欲しい API（将来的な UI 用）
GET /nutrition/daily?date=YYYY-MM-DD
目的：その日の DailyNutritionSummary を取得（なければ計算しても良い）。

認証：必須

プラン条件：

TRIAL / PAID：計算＋取得

FREE：

すでにある Daily を読むだけ or エラーで禁止（ポリシー次第）
振る舞い案：

Repo から DailyNutritionSummary を探す
見つからず、ユーザーが TRIAL / PAID なら ComputeDailyNutritionSummaryUseCase で計算して保存
それを返す
2-4. 食事記録との連動（外部的に見える挙動）
FoodEntry の作成 / 更新 / 削除時に：

すぐに栄養計算は走らせず、
必要なタイミング（/nutrition/meal など）で栄養計算を行うポリシーもアリ。
現状の方針：

Update / Delete 時に DailyNutritionSummary の再集計 を行う（MealNutrition は前段で生成されている想定）
「MealNutrition の再推定」が必要な場合は、/nutrition/meal のような評価 API で明示的に行う。 3. 内部仕様（ドメイン / UseCase / ポート）
3-1. Estimator ポート（栄養推定）
NutritionEstimatorPort
class NutritionEstimatorPort(Protocol):
def estimate_for_entries(
self,
user_id: UserId,
date: date,
entries: list[FoodEntry],
) -> list[MealNutrientIntake]:
"""
指定した FoodEntry 群について、
1 食分の栄養ベクトルを推定して返す。 - 失敗時は NutritionEstimationFailedError などを投げる。
"""
...
実装例：

StubNutritionEstimator: amount*value から雑に P/F/C を割り振るスタブ
OpenAINutritionEstimator: LLM に投げて食品名＋量から推定する実装（将来）
3-2. Repository ポート
MealNutritionSummaryRepositoryPort
class MealNutritionSummaryRepositoryPort(Protocol):
def get_by_user_and_meal(
self,
user_id: UserId,
date*: date,
meal_type: MealType,
meal_index: int | None,
) -> MealNutritionSummary | None: ...

    def list_by_user_and_date(
        self,
        user_id: UserId,
        date_: date,
    ) -> list[MealNutritionSummary]: ...

    def save(self, summary: MealNutritionSummary) -> None: ...

DailyNutritionSummaryRepositoryPort
class DailyNutritionSummaryRepositoryPort(Protocol):
def get*by_user_and_date(
self,
user_id: UserId,
date*: date,
) -> DailyNutritionSummary | None: ...

    def save(self, summary: DailyNutritionSummary) -> None: ...

3-3. UseCase：1 食分の栄養計算
ComputeMealNutritionUseCase
責務：
ある (user_id, date, meal_type, meal_index) に属する FoodEntry をもとに、
その 1 食分の MealNutritionSummary を推定して保存する。

入力：

user_id: UserId
date: date
meal_type: str or MealType
meal_index: int | None
流れ（概略）：

プランチェック：

UserRepo などから現在の User を取得
plan in (TRIAL, PAID) 以外 → エラー（PermissionDenied 的な）
FoodEntryRepo からその食事に属するエントリを取得：

(user_id, date, meal_type, meal_index) にマッチするもの
deleted_at is None のみ
NutritionEstimatorPort に渡して推定：

estimator.estimate_for_entries(user_id, date, entries)
失敗時 → NutritionEstimationFailedError
既存の MealNutritionSummary があれば上書き / なければ新規作成：

generated_at = clock.now()
source = NutrientSource("llm") or "stub" など
Repo.save で保存

UC の戻り値として MealNutritionSummary を返す。

3-4. UseCase：1 日分の栄養合計
ComputeDailyNutritionSummaryUseCase
責務：
指定 (user_id, date) について、
その日の全 MealNutritionSummary から DailyNutritionSummary を再計算・保存する。

入力：

user_id: UserId
date: date
流れ：

（ここではプランチェック必須かどうかは設計次第だが、基本 TRIAL/PAID 前提でよい）

MealNutritionSummaryRepo から list_by_user_and_date(user_id, date) を取得

栄養素ごとに value を合計：

totals[NutrientCode] = Σ meal.amount.value
unit が混在していた場合はエラー or 例外（基本混在しない前提）
合計結果から DailyNutrientIntake のリストを生成

Meal が 0 件なら nutrients=[]（0 サマリ）
既存の DailyNutritionSummary があれば id を引き継ぎ上書き：

なければ新規 DailyNutritionSummaryId を採番
generated_at = clock.now()
Repo.save(summary)

summary を戻り値として返す

3-5. FoodEntry 更新/削除との関係（内部仕様）
UpdateFoodEntryUseCase は「更新前の日付」を一緒に返す ResultDTO を持つ：

UpdateFoodEntryResultDTO(entry=更新後 DTO, old_date=更新前 date)
DeleteFoodEntryUseCase は「削除されたエントリの date」を返す ResultDTO を持つ：

DeleteFoodEntryResultDTO(date=削除対象の日付)
meal_route（API 層）での責務：

Update の場合：

影響する日付セット： {old_date, new_date}
各日付に対して ComputeDailyNutritionSummaryUseCase.execute(user_id, date) を呼ぶ
Delete の場合：

削除された date に対して ComputeDailyNutritionSummaryUseCase.execute(user_id, date) を呼ぶ
MealNutritionSummary の「再推定」が必要なシナリオでは、
/nutrition/meal API → ComputeMealNutritionUseCase → ComputeDailyNutritionSummaryUseCase の順で呼ぶ。

食事内容が大きく変わった場合など、フロントから明示的に「この食事を再評価する」トリガーを踏むイメージ。

4. まとめ（栄養計算の仕様のポイント）
   役割の分割

ComputeMealNutritionUseCase：
→ FoodEntry（品目の列）から「1 食分の栄養ベクトル」を推定して保存。
ComputeDailyNutritionSummaryUseCase：
→ その日分の MealNutritionSummary から「1 日分の栄養合計」を計算して保存。
プラン制約

両方の UC は TRIAL / PAID ユーザーのみ実行可能。
FREE ユーザーが栄養計算 API を叩いた場合はエラー（HTTP 層では 403/402 相当）。
FoodEntry との関係

FoodEntry は「何をどれだけ食べたか」という生ログ。
Meal/ Daily はそれを数値に変換した「栄養の状態」。
Update / Delete で FoodEntry が動くたびに、
少なくとも Daily の再集計は行って整合性を保つ。
他機能との接続

記録完了判定は meals_per_day + main FoodEntry の有無で行う（栄養計算とは独立）。
日次レポート・提案は、この Meal & Daily の結果を前提として LLM を回す。
この仕様をベースにしておけば、あとは
各ユースケースやルータで「どのタイミングで Meal を再推定するか」「どこまで自動／明示トリガーにするか」だけを調整すれば、かなり柔軟かつ筋の良い構造で回せると思います 💡

いいですね、ここまで土台が揃ってきたので、「課金処理」をちゃんと仕様にしておきましょう 💪
これまでと同じく：

概要
データ仕様（何を持つか）
外部仕様（UX / API）
内部仕様（ドメイン / UseCase / ポート / Webhook / 連携）
の流れで整理します。

課金処理（Billing / Stripe）の仕様 0. 概要
目的

ユーザーに対して 7 日間の無料トライアル → 有料プラン（Stripe） or 無料プラン という流れを提供し、
課金状況に応じて「使える機能」を制御する。
プランと機能制限の関係

プランは UserPlan として TRIAL / FREE / PAID の 3 種類：

TRIAL（試用期間中）

登録から 7 日間有効
有料と同じ機能が使える（栄養計算・日次レポート・提案機能）
PAID（有料）

Stripe でサブスク契約が「アクティブ」なユーザー
TRIAL と同じく全機能利用可能
FREE（無料）

trial 終了 ＋ Stripe 上の有効なサブスクなし

利用可能機能：

食事記録（FoodEntry）の CRUD
プロフィール編集
利用不可（もしくは制限される）機能：

栄養計算（Meal / Daily）
日次レポート生成
提案機能
Stripe の役割

決済・サブスクリプションの管理を担当。
バックエンド側は Stripe からの Webhook を受け取って
→ UserPlan や内部の Billing 状態を更新する。

1. データ仕様（ドメイン視点）
   1-1. User + Trial 情報（auth 側）
   既にある定義を前提とすると：

User(
id: UserId,
email: EmailAddress,
hashed_password: HashedPassword,
name: str,

    plan: UserPlan,        # "trial" / "free" / "paid"
    trial_info: TrialInfo, # trial_ends_at: datetime | None

    has_profile: bool,
    created_at: datetime,
    deleted_at: datetime | None,

)
新規登録時：

plan = TRIAL
trial_info.trial_ends_at = now + 7 days
trial が終了したかどうかは TrialInfo.is_trial_active で判定 (now < trial_ends_at)

1-2. Billing ドメイン（Stripe 連携情報）
BillingAccount（例）

BillingAccount(
id: BillingAccountId, # 内部用 ID（User 1:1 でも可）
user_id: UserId,

    stripe_customer_id: str,      # "cus_xxx"
    stripe_subscription_id: str | None, # "sub_xxx"
    subscription_status: BillingSubscriptionStatus,  # active / past_due / canceled / none

    current_plan: UserPlan,       # auth.User.plan と同期（冗長でもOK）
    updated_at: datetime,

)
BillingSubscriptionStatus 例：

NONE（サブスクなし）
ACTIVE
PAST_DUE
CANCELED
※ この Billing 情報を User に直接持たせるか、別テーブルに切るかは実装時の好みだが、DDD 的には domain/billing にコンテキストを切るのがきれい。

1-3. プラン状態の決定ロジック（概念）
最終的に「このユーザーは今 TRIAL / FREE / PAID のどれか？」を決めるためのルール：

trial_info.is_trial_active == True
→ 論理プランは TRIAL
trial が終了しており、Stripe 上の subscription_status が ACTIVE
→ 論理プランは PAID
上記どちらにも当てはまらない
→ FREE
→ これに基づき auth.User.plan を更新しておく（冗長でも可。plan を参照すれば早い）。

2. 外部仕様（UX / API 視点）
   2-1. ユーザーの課金フロー（UX）
   アカウント作成

自動的に 7 日間の TRIAL 開始。
課金ページ（Upgrade）

アプリ内の「アップグレード」ボタンを押すと、

Stripe Checkout へ遷移（サブスク購入用）
購入成功後：

Stripe → Webhook → バックエンド
バックエンド側で該当ユーザーを PAID に更新。
サブスクの管理

「プランを管理する」ボタンで Stripe Customer Portal へ遷移。

ユーザーはそこで：

サブスクのキャンセル
支払い方法の更新
などができる。
キャンセル後

Stripe 側でサブスクがキャンセルされ、期間終了後に canceled になる。
Webhook で通知を受けて User.plan = FREE へ。
TRIAL 終了

7 日経過すると trial_info.is_trial_active == False になる。
サブスクがなければ FREE に降格。
サブスクがあれば PAID として扱う。
2-2. API 仕様（外部インターフェース）
(1) POST /billing/checkout-session
目的：Stripe Checkout セッションを作成し、その URL をフロントに渡す。

認証：必須

入力：特になし（フロント側プランは 1 種類想定）

振る舞い：

User に対応する stripe_customer_id があるかチェック：

なければ Stripe 上で Customer を作成し、BillingAccount に保存。
Stripe の Checkout セッションを作成（サブスク用）。

セッション URL をレスポンスとして返す。

レスポンス例：

{
"checkout_url": "https://checkout.stripe.com/c/session_id"
}
(2) GET /billing/portal-url
目的：Stripe Customer Portal への URL を取得する。

認証：必須

振る舞い：

stripe_customer_id がなければエラー（BAD_REQUEST 相当）
Stripe の Billing Portal Session を作成
URL を返す
レスポンス例：

{
"portal_url": "https://billing.stripe.com/p/session_id"
}
(3) POST /billing/stripe/webhook
目的：Stripe からのイベント通知を受け取り、プラン状態を更新する。

認証：署名検証（Stripe の signing secret）で行う。

主に扱うイベント例：

checkout.session.completed

サブスク開始トリガー。
→ 該当ユーザーの stripe_subscription_id 登録
→ subscription_status = ACTIVE
→ User.plan = PAID
customer.subscription.created

customer.subscription.updated

status が active / past_due / canceled / unpaid 等に変わったときに BillingAccount / User.plan を更新。
customer.subscription.deleted

Webhook 仕様のポイント：

Stripe の署名検証を行う（イベント偽装防止）。
イベント ID (event.id) をログ or DB に保存し、同じ ID のイベントを二度処理しない（冪等性）。
レスポンス：

Stripe 推奨通り、正常時は 200 OK（ボディは {} 程度）。
署名検証失敗なら 400 / 401。
2-3. プラン判定に関する外部シグナル
/auth/me などで返すユーザー情報に以下を含める：

plan: "trial" / "free" / "paid"
trial_ends_at
これによってフロント側は：

「残り ◯ 日トライアルです」
「プランをアップグレードしましょう」
「現在のプラン：有料」
の表示を制御できる。

3. 内部仕様（ドメイン / UseCase / ポート / Webhook）
   3-1. Billing ドメイン（app/domain/billing のイメージ）
   Entity: BillingAccount
   前述の通り。

エラー例
StripeCustomerNotFoundError
StripeSubscriptionNotFoundError
BillingInconsistentStateError（Stripe と内部の状態が噛み合っていない等）
3-2. ポート（Application 層）
BillingRepositoryPort（BillingAccount 用）
class BillingRepositoryPort(Protocol):
def get_by_user_id(self, user_id: UserId) -> BillingAccount | None: ...
def save(self, account: BillingAccount) -> None: ...
StripeClientPort（Stripe への依存を抽象化）
class StripeClientPort(Protocol):
def create_customer(self, email: str, user_id: str) -> str: ...
def create_checkout_session(self, customer_id: str, success_url: str, cancel_url: str) -> str: ...
def create_billing_portal_session(self, customer_id: str, return_url: str) -> str: ...
def parse_event(self, payload: bytes, sig_header: str) -> StripeEvent: ... # 必要に応じて subscription の取得など
実装：

StripeClient（stripe-python を内部で利用）
3-3. UseCase 一覧
CreateCheckoutSessionUseCase
GetBillingPortalUrlUseCase
HandleStripeWebhookUseCase
UpdateUserPlanFromBillingUseCase（Webhook 内部または別 UC として）
3-4. 各 UseCase の仕様（ざっくり）
CreateCheckoutSessionUseCase
入力：user_id, success_url, cancel_url

フロー：

BillingAccount を取得（なければ作成）

StripeClient で customer を作成 → stripe_customer_id 保存
StripeClient.create_checkout_session を呼ぶ

返ってきた URL を返却

GetBillingPortalUrlUseCase
入力：user_id, return_url

フロー：

BillingAccount を取得
stripe_customer_id がなければエラー
StripeClient.create_billing_portal_session を呼ぶ
URL を返す
HandleStripeWebhookUseCase
入力：payload: bytes, signature_header: str

フロー：

StripeClient.parse_event で署名検証＋イベント解析

event.type ごとに処理分岐：

checkout.session.completed：

セッションから customer, subscription を取得

対応する user_id を特定（metadata or customer metadata）

BillingAccount を更新：

stripe_customer_id, stripe_subscription_id, subscription_status = ACTIVE
User.plan = PAID に更新（UserRepository 更新）

customer.subscription.updated / deleted：

subscription.status に応じて BillingAccount / User.plan を更新

active → plan = PAID

canceled / unpaid / past_due の場合：

trial も expired → plan = FREE
イベント ID をログ or DB に保存し、二重処理を防ぐ

3-5. プランチェックの組み込み
栄養計算 / 日次レポート / 提案などの UseCase で、

User.plan と trial_info を見て「この機能を実行して良いか」を判定する。
例：ComputeMealNutritionUseCase 冒頭：

user = user_repo.get_by_id(user_id)
if not is_feature_available("nutrition", user):
raise PermissionDeniedError("Nutrition features require trial or paid plan.")
is_feature_available のロジック（擬似）：

def is_feature_available(feature: str, user: User) -> bool: # trial 中は有料機能を全て解放
if user.trial_info.is_trial_active:
return True # trial 終了後は plan == PAID のみ
if user.plan == UserPlan.PAID:
return True
return False 4. まとめ（課金処理仕様のキモ）
Stripe は「決済・サブスク情報のソース・オブ・トゥルース」
→ こちらは Stripe Webhook を受けて内部の Billing / User.plan を更新する。

アプリ側の論理プラン（TRIAL / FREE / PAID）は User に閉じておく
→ 機能制御は User.plan + TrialInfo を見るだけで判定可能。

MVP としての範囲

7 日間の TRIAL を Auth で付与（登録時）
Stripe Checkout + Billing Portal を使った 単一プランのサブスク
Webhook による PAID / FREE への状態遷移
「栄養計算 / 日次レポート / 提案」は TRIAL / PAID のみに制限する
この仕様を前提に、
domain/billing, application/billing, infra/billing/stripe, api/http/billing_route.py を
いつもの DDD/クリーンアーキ構造に乗せていけば、そのまま実装にスライドできるはずです 💡

いいですね、じゃあ今回は 記録完了判定（DailyLogCompletion）だけ にフォーカスして、
これまでと同じノリで

概要
データ仕様（何を見て何を返すか）
外部仕様（UX / API としてどう扱うか）
内部仕様（ドメイン / UseCase / Repo / 他機能との関係）
を整理していきます 💪

記録完了判定（DailyLogCompletion）の仕様 0. 概要
目的

「その日、その人は『必要な回数の食事ログ』をちゃんと記録し終えているか？」を判定する。

判定結果は：

日次レポート生成可否
提案機能の前提
将来的なバッジ（連続記録・達成報酬）のトリガー
に使われる。
対象

ある (user_id, date) のペアに対して
→ 「記録完了（completed）かどうか」を判断する。

1. データ仕様（何を見て何を返すか）
   1-1. 前提となるデータ
   Profile
   user_id

meals_per_day: int （1 日あたりのメイン食事回数）

例：2 / 3 / 4
1 <= meals_per_day であることが必須（0 や負数はエラー）
FoodEntry
user_id

date

meal_type: "main" | "snack"

meal_index: int | None

main のとき：1..meals_per_day
snack のとき：None
deleted_at: datetime | None（ソフトデリート）

deleted_at is not None のものは記録完了判定の対象外
1-2. 記録完了の定義（ビジネスルール）
ある (user_id, date) に対して：

Profile が存在し、meals_per_day = N (>=1) が設定されていること。

その日の FoodEntry のうち、

meal_type == "main"
deleted_at is None
の meal_index を集める。
集合 {1, 2, ..., N} が すべて含まれているなら記録完了。

→ これを満たせばその日は 「記録完了（completed）」。
snack (meal_type == "snack") は完了判定には関与しない。

1-3. 判定結果としての情報
DailyLogCompletionResult（論理的 DTO）

user_id: UserId

date: date

meals_per_day: int

is_completed: bool

filled_indices: list[int]

記録済みの main meal_index（例：[1, 2]）
missing_indices: list[int]

まだ記録されていない main meal_index（例：[3]）
例：

meals_per_day = 3
その日の main 食事が meal_index = 1, 3 のみ
→ is_completed = False
→ filled_indices = [1, 3]
→ missing_indices = [2]

1-4. エラーとして扱うケース
Profile が存在しない場合：

「記録完了」を判定する前提がないため、エラーとする
（例：DailyLogProfileNotFoundError）
meals_per_day < 1 の場合：

無効な設定として、エラーとする
（例：InvalidMealsPerDayError）
「とりあえず 3 回扱いにして判定…」のようなデフォルトは取らず、
Profile 未設定の状態では上位機能（日次レポート・提案なども利用不可）という前提にする。

2. 外部仕様（UX / API 視点）
   2-1. 誰が・いつ使うか
   主に サーバー内部のロジック から利用する判定（UseCase）だが、

将来的には以下のような UI 要素にも活用したい：

日次の進捗表示

1 日の記録状況を「○/N 食記録済み」と表示。
例：「3 回中 2 回記録済み（残り：3 回目）」。
レポートボタンの活性 / 非活性

is_completed == true の日だけ「今日のレポートを生成」ボタンを有効にする。
未完了なら「あと 1 食記録するとレポートが作成できます」のような表示。
連続記録・バッジ表示

「連続 ◯ 日記録完了」バッジなどの判定に利用。
2-2. API を公開するかどうか
現時点では 内部 UC として使う前提 だが、
UI から直接見たい場合は例えば以下のようなエンドポイントもあり得る：

GET /daily/log/status?date=YYYY-MM-DD
認証：必須

機能：

(user_id, date) について is_completed / missing_indices などを返す。
レスポンス例：

{
"date": "2025-11-30",
"meals_per_day": 3,
"is_completed": false,
"filled_indices": [1, 3],
"missing_indices": [2]
}
※ 必須ではないが、
「ホーム画面に今日の進捗を出したい」などのときに便利。

2-3. 他機能から見た「外部仕様」
日次レポート生成（DailyNutritionReport）

対象日が is_completed == true でなければ生成不可。
例：DailyLogNotCompletedError を発生させる。
提案機能（MealRecommendation）

直近 5 日分のレポートを生成する前提として、
各日が記録完了している必要がある（＝レポートが存在する前提）。
バッジ / 報酬

「記録完了した日」をカウント or 連続数計算するときの根拠に使う。 3. 内部仕様（ドメイン / UseCase / Repo）
3-1. ドメイン層（app/domain/meal / app/domain/profile）
Profile：

meals_per_day の制約（1 以上）
FoodEntry：

meal_type / meal_index の関係を正しく維持（main に対して 1..N）
ドメインエラー：

DailyLogProfileNotFoundError（Profile 未設定）
InvalidMealsPerDayError
※ 記録完了自体は「ドメインサービス」寄りだが、
実装上は アプリケーション層の UseCase に寄せる方針で OK。

3-2. Repository ポート
ProfileRepositoryPort
class ProfileRepositoryPort(Protocol):
def get*by_user_id(self, user_id: UserId) -> Profile | None: ...
FoodEntryRepositoryPort（既存）
class FoodEntryRepositoryPort(Protocol):
def list_by_user_and_date(
self, user_id: UserId, date*: date
) -> list[FoodEntry]: ...
list_by_user_and_date は deleted_at is None のみを返す前提。
3-3. UseCase：CheckDailyLogCompletionUseCase
責務

(user_id, date) に対して、
「その日のメイン食事が meals_per_day 回分すべて記録されているか」を判定する。
インターフェース（論理）

class CheckDailyLogCompletionUseCase:
def **init**(
self,
profile_repo: ProfileRepositoryPort,
food_entry_repo: FoodEntryRepositoryPort,
): ...

    def execute(self, user_id: UserId, date: date) -> DailyLogCompletionResultDTO:
        ...

処理フロー

Profile 取得

profile = profile_repo.get_by_user_id(user_id)
未取得 → DailyLogProfileNotFoundError を投げる
meals_per_day = profile.meals_per_day

meals_per_day < 1 → InvalidMealsPerDayError
FoodEntry 一覧取得

entries = food_entry_repo.list_by_user_and_date(user_id, date)
deleted_at is None のもののみが返る前提
main エントリだけを抽出

meal_type == "main" のもののみ対象
meal_index が None / 範囲外の場合はスキップ or バグ検知（実装方針次第）
その日の main のインデックス集合を作成

main_indices = {e.meal_index for e in main_entries}
必要なインデックス集合を作成

required = {1, 2, ..., meals_per_day}
missing_indices = sorted(required - main_indices)

filled_indices = sorted(main_indices & required)
is_completed = len(missing_indices) == 0
DailyLogCompletionResultDTO として返す：

DailyLogCompletionResultDTO(
user_id=user_id,
date=date,
meals_per_day=meals_per_day,
is_completed=is_completed,
filled_indices=filled_indices,
missing_indices=missing_indices,
)
3-4. 上位 UseCase での利用例
日次レポート生成 UC
completion = check_daily_log_completion_uc.execute(user_id, date)
if not completion.is_completed:
raise DailyLogNotCompletedError(
f"Daily log not completed. missing={completion.missing_indices}"
)

# → ここで初めて DailyNutritionReport の生成に進む

バッジ判定 UC（将来的な例）
result = check_daily_log_completion_uc.execute(user_id, date)
if result.is_completed: # 連続日数カウント / バッジ付与ロジックへ 4. まとめ（記録完了判定のキモ）
何をしているか：

Profile.meals_per_day と、当日の main FoodEntry の有無だけを見て
「その日に必要なメイン食事回数分が、ちゃんと記録されているか」を判定する。
どう使われるか：

日次レポート生成の前提チェック
提案機能の前段（＝レポートが揃っているかどうか）
将来のバッジ・連続記録などのトリガー
なぜ分離しているか：

栄養計算（Meal/Daily の数値）とは独立した概念として
「ユーザーが行動として記録を完了しているか」を見るため。
→ 食事内容の質ではなく、「記録の行動」を評価する軸。
この仕様を前提にしておけば、
あとは「DailyLogCompletionUseCase の実装」と「各 UC からの呼び出し」を揃えるだけで、
レポート・提案・バッジに一貫した「完了判定の土台」を提供できるようになります 💡

いいですね、では食事記録（FoodEntry）だけにフォーカスして、
Auth / Profile / Target と同じノリで仕様を整理していきます 💪

食事記録（FoodEntry）機能の仕様 0. 概要
目的

日々の食事内容を「1 品（1 エントリ）単位」で記録する。

1 日の中で「何回目の食事か（meal_index）」と「メインか間食か（meal_type）」を区別して管理する。

このデータが 栄養計算・記録完了判定・レポート・提案 のすべての土台になる。

1. データ仕様（ドメイン視点）
   1-1. エンティティ：FoodEntry
   FoodEntry(
   id: FoodEntryId,
   user_id: UserId,
   date: date, # その食品を食べた日（ローカルな日付）
   meal_type: MealType, # "main" or "snack"
   meal_index: int | None, # main: 1..meals_per_day, snack: None

name: str, # 食品名・メニュー名

amount_value: float | None, # 数量（150 など）
amount_unit: str | None, # 単位（"g", "ml", "piece" など）
serving_count: float | None, # 何人前 / 何皿分 か

note: str | None, # メモ（任意）

created_at: datetime,
updated_at: datetime | None,
deleted_at: datetime | None, # soft delete 用

)

1-2. ValueObject / Enum
FoodEntryId：UUID ラッパ

MealType：

"main"：メインの食事（朝/昼/夜など）

"snack"：間食（おやつなど）

主なドメインエラー：

InvalidMealTypeError

InvalidMealIndexError

InvalidFoodAmountError

FoodEntryNotFoundError

1-3. 不変条件（Invariants）
meal_type と meal_index の関係

meal_type == "main" のとき：

meal_index は 1 <= meal_index <= meals_per_day

meal_type == "snack" のとき：

meal_index is None

量の指定

amount_value + amount_unit と serving_count の少なくともどちらか一方は指定されていること

両方 None → InvalidFoodAmountError

どちらも指定されていても良いが、意味づけは「量の補足情報」として扱う想定

負の値は不可（amount_value >= 0, serving_count >= 0）

削除

deleted_at が設定された FoodEntry は、
通常の取得 / 集計 / 記録完了判定の対象には含めない（ソフトデリート）

所有権

user_id は常にログイン中ユーザー自身である（他人の FoodEntry は操作不可）

2. 外部仕様（API / UX 視点）
   2-1. 利用者と前提
   操作主体：ログイン済みユーザー

プロフィールの meals_per_day が設定されていると、「何回目の main 食事か」が明確になる

食事記録自体は FREE / TRIAL / PAID 全プランで利用可能
（ただし、栄養計算などは TRIAL / PAID のみ）

2-2. ユースケース（UX レベル）
その日の 1 回目の食事を登録

「今日」「1 回目」「main」「メニュー名」「量」を入力して保存

UI 上では「1 回目 / 2 回目 / 3 回目 / 間食」などのフィルタで表示される

2 回目・3 回目の食事、間食の追加

2 回目の main、間食などを追加で登録

1 つの meal_index に複数 FoodEntry（おかず、飲み物など）が紐づく

食事内容の編集

名前・量・meal_type の変更

日付変更（別の日に移動）

main ⇔ snack に切り替えるケースもあり得る（このとき meal_index の調整が必要）

食事の削除

「間違えて入力した」「もうこの品目はなかったことにしたい」

ソフトデリート（消しても履歴には残せる設計）だが、ユーザー視点では「消えた」ように見える

ある日の一覧表示

date を指定して、その日の全 FoodEntry を取得

UI では main / snack のカテゴリ分け、meal_index の順序で表示

将来的に：

前日 / 前回の食事を「コピーして今日に貼り付ける」などの機能も追加しやすい設計。

2-3. API 仕様（HTTP レイヤ）
すでにあるルートに沿う形で、「外部仕様」として整理します。

(1) POST /meal-items
目的：FoodEntry の新規作成

認証：必須

リクエスト例：

{
"date": "2025-11-30",
"meal_type": "main",
"meal_index": 1,
"name": "鶏むね肉のグリル",
"amount_value": 150.0,
"amount_unit": "g",
"serving_count": null,
"note": "皮なし"
}
バリデーション：

meal_type は "main" or "snack"

meal_type == "main" の場合 meal_index 必須、かつ 1..meals_per_day

meal_type == "snack" の場合 meal_index は null or 無視

amount_value + amount_unit と serving_count の少なくとも一方がセットされていること

レスポンス：

201 Created + 作成された FoodEntry の情報

(2) GET /meal-items?date=YYYY-MM-DD
目的：指定した 1 日分の FoodEntry 一覧を取得

認証：必須

クエリパラメータ：

date（必須）

振る舞い：

deleted_at is None のエントリのみ

main / snack 混ざった一覧（ソート順は date, meal_type, meal_index, created_at 等）

レスポンス例：

{
"items": [
{
"id": "entry-uuid-1",
"date": "2025-11-30",
"meal_type": "main",
"meal_index": 1,
"name": "鶏むね肉のグリル",
"amount_value": 150.0,
"amount_unit": "g",
"serving_count": null,
"note": "皮なし"
},
{
"id": "entry-uuid-2",
"date": "2025-11-30",
"meal_type": "main",
"meal_index": 1,
"name": "ご飯",
"amount_value": 200.0,
"amount_unit": "g",
"serving_count": null,
"note": null
},
{
"id": "entry-uuid-3",
"date": "2025-11-30",
"meal_type": "snack",
"meal_index": null,
"name": "ヨーグルト",
"amount_value": 1.0,
"amount_unit": "pack",
"serving_count": null,
"note": null
}
]
}
(3) PATCH /meal-items/{entry_id}
目的：既存の FoodEntry を更新（フル更新として扱う）

認証：必須

リクエストボディは POST と同じフォーマット。

振る舞い：

エントリが存在しない → 404（FoodEntryNotFoundError）

バリデーションは作成時と同様

日付を変えると「その FoodEntry が別の日に移動する」扱い

レスポンス：

更新後の FoodEntry

(4) DELETE /meal-items/{entry_id}
目的：FoodEntry の削除（ソフトデリート）

認証：必須

振る舞い：

deleted_at をセット（多重 DELETE は idempotent に扱う）

204 No Content

2-4. 他機能との関係（外部的な期待）
記録完了判定（DailyLogCompletion）

meal_type == "main" & deleted_at is None の FoodEntry を対象に、
meal_index のセット {1..meals_per_day} が埋まっているかを判定する。

栄養計算

栄養推定（MealNutritionSummary）は「同じ (user_id, date, meal_type, meal_index) に属する FoodEntry 群」を入力とする。

レポート / 提案

日次レポートや提案機能は、FoodEntry → Meal → Daily で求めた栄養から間接的に FoodEntry の内容を振り返る。

3. 内部仕様（ドメイン / UseCase / Repo）
   3-1. ドメイン層（app/domain/meal）
   Entity: FoodEntry
   上記フィールドの VO を持つエンティティ。

コンストラクタ / ファクトリで Invariants をチェック：

meal_type / meal_index の整合性

量指定の必須チェック

数値の非負チェック

ValueObjects
MealType("main" | "snack")

FoodEntryId(UUID)

エラー：

InvalidMealTypeError

InvalidMealIndexError

InvalidFoodAmountError

FoodEntryNotFoundError

3-2. Repository Port（app/application/meal/ports）
class FoodEntryRepositoryPort(Protocol):
def create(self, entry: FoodEntry) -> None: ...
def update(self, entry: FoodEntry) -> None: ...
def delete(self, entry: FoodEntry) -> None: ... # ソフトデリート
def get*by_id(self, user_id: UserId, entry_id: FoodEntryId) -> FoodEntry | None: ...
def list_by_user_and_date(self, user_id: UserId, date*: date) -> list[FoodEntry]: ...
list_by_user_and_date は deleted_at is None のみ返す。

3-3. UseCase（一連の CRUD）
CreateFoodEntryUseCase
入力：CreateFoodEntryInputDTO

date, meal_type, meal_index, name, 量情報, note

流れ：

DTO → VO（MealType 等） → Entity 生成（Invariants チェック）

Repo.create で保存

FoodEntryDTO として返す

栄養計算や Daily 再計算は ここでは行わない。
→ 上位の栄養 UC or API レイヤが担う（今は Router でやっている）。

UpdateFoodEntryUseCase
入力：UpdateFoodEntryInputDTO

流れ：

get_by_id(user_id, entry_id) で既存取得

見つからなければ FoodEntryNotFoundError

DTO の内容で新しい Entity を組み立て（id/user_id/created_at/deleted_at は維持）

Repo.update

更新前・更新後の日付を返す DTO（たとえば UpdateFoodEntryResultDTO(entry, old_date)）

DeleteFoodEntryUseCase
入力：entry_id

流れ：

get_by_id で取得

見つからなければ FoodEntryNotFoundError（または冪等のために無視）

Repo.delete（ソフトデリート）

削除された date を返す DTO（Daily 再計算用）

ListFoodEntriesByDateUseCase
入力：user_id, date

流れ：

Repo.list_by_user_and_date で取得し、FoodEntryDTO のリストにして返す

3-4. infra 層（SQLAlchemy モデル）
food_entries テーブル（すでにある想定）

カラム 型 備考
id UUID PK
user_id UUID users.id FK + index
date DATE
meal_type VARCHAR "main" / "snack"
meal_index INT main のとき 1..N / snack は NULL
name TEXT
amount_value FLOAT nullable
amount_unit VARCHAR nullable
serving_count FLOAT nullable
note TEXT nullable
created_at TIMESTAMPTZ default now()
updated_at TIMESTAMPTZ
deleted_at TIMESTAMPTZ nullable（soft delete）
SqlAlchemyFoodEntryRepository が FoodEntryRepositoryPort を実装し、

モデル ↔ エンティティの変換を担う。

4. まとめ（食事記録の仕様のポイント）
   役割：

「ユーザーが何をどれだけ食べたか」を一番細かい粒度で保持する、コアデータ。

栄養計算・記録完了判定・日次レポート・提案のすべては FoodEntry からスタートする。

外部仕様：

/meal-items 系の API で、日付・回数（meal_index）・種類（main/snack）・量・メモを CRUD できる。

ある日の一覧取得は GET /meal-items?date=YYYY-MM-DD で行う。

UI 的には「1 回目 / 2 回目 / 3 回目 / 間食」ごとに複数の FoodEntry を束ねて表示する。

内部仕様：

Domain で meal_type / meal_index / 量 の整合性をきっちり守る。

Application の UseCase は「FoodEntry の作成・更新・削除・取得」に責務を絞る。

栄養計算や Daily の再計算は FoodEntry の責務ではなく、上位の栄養系 UseCase or API レイヤーが担う（疎結合を維持）。

この状態まで仕様を固めておくと、
あとで「MealNutritionSummary / DailyNutritionSummary / 記録完了 / レポート / 提案」という上位レイヤも
かなりスムーズに乗せていけると思います 💡

いいですね、じゃあ最後のピースである 提案機能（Recommendation） をまとめていきます 💪
これまでと同じく：

概要
データ仕様（何を持つか）
外部仕様（UX / API）
内部仕様（ドメイン / UseCase / ポート / JOB）
の順で整理します。

提案機能（MealRecommendation）の仕様 0. 概要
目的

日次レポート（DailyNutritionReport）から「最近の傾向」を読み取り、
「じゃあ次はどう食べるといいか？」という提案 を LLM で生成する。

ユーザーにとっては：

日々のレポートが「過去の振り返り」、
提案は「これからどう行動するか」のガイド、という位置づけ。
位置づけ

パイプラインとしては：
食事記録（FoodEntry）
→ 栄養計算（Meal / Daily）
→ 記録完了判定
→ 日次レポート（DailyNutritionReport）
→ 提案（MealRecommendation） ← 今ここ

前提

提案の生成には 直近 N 日分（現状 5 日）のレポート が必要。
提案機能は TRIAL / PAID ユーザーのみ利用可能。

1. データ仕様（ドメイン視点）
   1-1. MealRecommendation エンティティ
   1 ユーザー × 1 日あたり最大 1 件（「その日の提案」）。

MealRecommendation(
id: MealRecommendationId,
user_id: UserId,

    generated_for_date: date,   # この日までの履歴をもとにした提案（通常「今日」）

    body: str,                  # メインの提案文（本文）
    tips: list[str],            # 実行可能なアクションの箇条書き

    created_at: datetime,

)
generated_for_date の意味：

「この日までの直近 5 日分レポートを見て作った提案」という基準日。
通常は「ジョブ実行日」＝「今日」を指定する。
1-2. 制約
(user_id, generated_for_date) で高々 1 件。
1 日に何度も再生成しない（再生成ポリシーを設けるなら別 UC 経由）。
body と tips は LLM から返却された文章を基本そのまま保存。
1-3. 提案生成の材料（ドメイン的入力）
提案は次の情報を使って生成される：

Profile（性別/身長/体重などの基本情報）

Active な TargetDefinition（あれば）
→ 現在どんな栄養方針を目指しているか

直近 N 日分（現状 5 日）の DailyNutritionReport

各日の summary / good / improvement / tomorrow_focus
日付（trend を把握するため）
※ 数値的な栄養情報（DailyNutritionSummary）も入力に入れてもよいが、
現段階では 「レポートが数値をある程度言語化してくれている」 前提で、
レポートのテキストを主な材料にする想定。

2. 外部仕様（UX / API 視点）
   2-1. 誰が・いつ使うか
   操作主体：

まずは JOB（バッチ）による自動実行がメイン。
将来的には「ユーザーがボタンを押して手動で提案を取得」も同じ UC を通して実行。
前提：

ログイン済み
Profile 作成済み
該当ユーザーに 直近 5 日分の DailyNutritionReport が揃っていること
プランが TRIAL / PAID であること
2-2. ユースケース（UX レベル）
JOB による朝の自動提案

毎朝 7:00 頃にバッチが走り、

直近 5 日分のレポートがあるユーザー全員について、

今日の MealRecommendation を生成して保存。
ユーザーがアプリを開いたときに、

「今日の提案」が既に表示できる。
ユーザーによる手動実行（将来的）

ホーム画面に「最近の傾向から提案を見る」ボタン。

押したタイミングで GenerateMealRecommendationUseCase を叩く。

直近 5 日分レポートが揃っていれば提案生成、

足りなければ「あと ◯ 日のレポートが必要です」と表示。
2-3. API 仕様（外部インターフェース想定）
将来的に用意するイメージ：

(1) POST /nutrition/recommendation
目的：提案の生成（手動トリガー用）

認証：必須

プラン制約：TRIAL / PAID のみ

リクエストボディ（省略可）：

{
"base_date": "2025-11-30" // 省略時は「今日」
}
振る舞い：

base_date（省略時は today）を決定。
プランチェック。
Profile 取得（なければエラー）。
DailyNutritionReport_repo から list_recent(user_id, limit=5) を取得。
数が 5 未満 → NotEnoughDailyReportsError（400 or 409）。
generated_for_date = base_date に対する Recommendation が既に存在 → MealRecommendationAlreadyExistsError（409）。
LLM 入力を構築 → 提案生成 → 保存。
Recommendation をレスポンスで返す。
レスポンス例：

{
"generated_for_date": "2025-11-30",
"body": "直近 5 日間の食事はたんぱく質は安定している一方で、夜の炭水化物がやや多めの傾向があります。...",
"tips": [
"夕食の主食量をいつもより 20〜30% 減らしてみましょう。",
"間食はたんぱく質を含むもの（ヨーグルト、ナッツ等）に寄せると、血糖値の安定に役立ちます。"
]
}
(2) GET /nutrition/recommendation/latest
目的：最新の Recommendation を取得する（今日の or 直近の）。

認証：必須

振る舞い：

Repo から list_recent(user_id, limit=1) で最新を取得
なければ 404 or 空（「まだ生成されていません」）
（一覧 API /nutrition/recommendation/history などは必要に応じて拡張）

2-4. JOB から見た外部仕様
Job スクリプトは内部的に GenerateMealRecommendationUseCase を呼び出す。

外部サービス（フロント）からは直接ジョブを叩かず、

あくまで「バックグラウンドで定期的に提案が生成されている」という前提で表示。 3. 内部仕様（ドメイン / UseCase / ポート / JOB）
3-1. ドメイン層
Entity: MealRecommendation
前述の通り。

主なドメイン・アプリケーションエラー
NotEnoughDailyReportsError

直近 5 日分の日次レポートが揃っていない。
MealRecommendationAlreadyExistsError

同じ (user_id, generated_for_date) に既に提案が存在。
DailyLogProfileNotFoundError

Profile 未設定（記録完了判定などと整合）。
3-2. Repository ポート
MealRecommendationRepositoryPort
class MealRecommendationRepositoryPort(Protocol):
def get_by_user_and_date(
self,
user_id: UserId,
generated_for_date: date,
) -> MealRecommendation | None: ...

    def list_recent(
        self,
        user_id: UserId,
        limit: int,
    ) -> Sequence[MealRecommendation]: ...

    def save(self, recommendation: MealRecommendation) -> None: ...

3-3. LLM ポート（提案生成）
DTO: MealRecommendationLLMInput / Output
@dataclass
class MealRecommendationLLMInput:
user_id: UserId
base_date: date # この日までの履歴を見て提案する
profile: Profile
active_target: TargetDefinition | None
recent_reports: list[DailyNutritionReport] # 直近 N 日分

@dataclass
class MealRecommendationLLMOutput:
body: str
tips: list[str]
Port: MealRecommendationGeneratorPort
class MealRecommendationGeneratorPort(Protocol):
def generate(self, input: MealRecommendationLLMInput) -> MealRecommendationLLMOutput:
...
Stub 実装：StubMealRecommendationGenerator
→ 入力の base_date や len(recent_reports) をちょっと使って固定テキスト生成
本実装：OpenAIMealRecommendationGenerator（OpenAI API）
3-4. UseCase：GenerateMealRecommendationUseCase
責務

ユーザーの直近 N 日分の DailyNutritionReport を集め、
プラン・Profile・ActiveTarget なども考慮しつつ、
LLM で MealRecommendation を生成・保存する。
入力

user_id: UserId
base_date: date | None（デフォルトは「今日」）
依存

ProfileRepositoryPort
TargetRepositoryPort（Active Target を取得）
DailyNutritionReportRepositoryPort
MealRecommendationRepositoryPort
MealRecommendationGeneratorPort
ClockPort
User/Plan 判定用（UserRepositoryPort or PlanChecker）
処理フロー（論理）

base_date が None の場合，clock.now().date() を用いる。

User のプランチェック：

TRIAL / PAID 以外 → エラー（PermissionDenied 的）
Profile 取得：

profile_repo.get_by_user_id(user_id)
なければ DailyLogProfileNotFoundError
直近 N 日分の日次レポート取得：

recent_reports = daily_report_repo.list_recent(user_id, limit=N)
len(recent_reports) < N → NotEnoughDailyReportsError
generated_for_date = base_date と決定

既存 Recommendation チェック：

rec = recommendation_repo.get_by_user_and_date(user_id, generated_for_date)
存在する場合 → MealRecommendationAlreadyExistsError
Active ターゲット取得（オプション）：

active_target = target_repo.get_active_for_user(user_id)
なければ None（提案はそれでも生成可能）
LLM 入力 DTO を構築：

MealRecommendationLLMInput(user_id, base_date, profile, active_target, recent_reports)
LLM ポートから出力取得：

llm_output = generator.generate(llm_input)
MealRecommendation エンティティ生成：

created_at = clock.now()
recommendation = MealRecommendation.create(...)
Repo.save(recommendation)
Recommendation を戻り値として返す
3-5. JOB 用ロジック
目的：
毎日 1 回、全ユーザーに対して「今日の提案」を自動生成する。

フロー（概念）

date_today = clock.now().date()

user_repo.list_active_users() で対象ユーザー一覧を取得

各ユーザーについて：

GenerateMealRecommendationUseCase.execute(user_id, base_date=date_today) を呼ぶ

例外ハンドリング：

NotEnoughDailyReportsError →
そのユーザーでは「まだレポートが足りない」ためスキップ
MealRecommendationAlreadyExistsError →
すでに今日の提案がある → スキップ
その他 → ログ出力（ジョブ自体は継続）
要件

この JOB は 日次（日付を跨いだ後）に実行される前提。
実行には TRIAL / PAID 判定が組み込まれる → FREE ユーザーは対象外。 4. まとめ（提案機能のキモ）
何をしているか

直近 5 日分の日次レポートとユーザープロファイル、（あれば）ターゲットを元に、
「次にどう食べるといいのか？」を LLM に考えさせ、それを保存している。
いつ生成できるか

該当ユーザーに直近 5 日分の DailyNutritionReport が揃っているとき。
TRIAL / PAID プランのユーザーのみ。
同じ日付に複数回は生成せず、1 日 1 提案。
誰がトリガーするか

まずは JOB（自動実行）がメイン。
将来的には /nutrition/recommendation API を通じてユーザーが手動でトリガーすることも可能。
何に使われるか

ホーム画面などで「今日の提案」として表示。
履歴として蓄積されれば、「過去の提案」と「実際の行動・結果」を紐づけた分析も可能になる。
この仕様を前提にしておけば、
あとは LLM プロンプト設計と UI での見せ方を積み上げるだけで、
「ただの記録アプリ」から一歩進んだ 「記録 → 振り返り → 次の一手」 まで回るプロダクトに仕上げられるはずです 💡

いいですね、日次レポートはこのアプリの「楽しさ・フィードバック」の核なので、ここをちゃんと固めておくのはかなり大事です 💪
これまでと同じく：

概要
データ仕様（何を持つか）
外部仕様（UX / API）
内部仕様（ドメイン / UseCase / ポート）
の順で整理します。

日次レポート（DailyNutritionReport）の仕様 0. 概要
目的

1 日の食事と栄養状態を「言葉」で振り返れるようにする。
「良かった点」「改善ポイント」「明日のフォーカス」といった 行動につながるフィードバック を LLM で生成・保存する。
位置づけ

パイプライン全体の中では：
食事記録（FoodEntry）
→ 栄養計算（Meal / Daily）
→ 記録完了判定
→ 日次レポート（この仕様）
→ 提案（Recommendation）

の 4 段目。

プラン制約

「日次レポートの作成」は TRIAL / PAID ユーザーのみ利用可能。

FREE ユーザーは：

TRIAL / PAID 期間中に生成されたレポートの閲覧はできる想定だが、
新規レポートの作成は不可。

1. データ仕様（ドメイン視点）
   1-1. DailyNutritionReport エンティティ
   1 ユーザー × 1 日あたり最大 1 件。

DailyNutritionReport(
id: DailyNutritionReportId,
user_id: UserId,
date: date, # このレポートが対象とする日

    summary: str,         # 1 日全体の総評（本文）

    good_points: list[str],         # 良かった点
    improvement_points: list[str],  # 改善できそうな点
    tomorrow_focus: list[str],      # 明日意識したいこと・アクション

    created_at: datetime,

)
1-2. 制約
(user_id, date) で 高々 1 件。
一度生成したレポートは「その時点の振り返り」として基本的には上書きしない（再生成ポリシーが必要なら別途）。
レポートは 「その時点までに存在しているデータ（ターゲット・栄養状態）」に基づくスナップショット として扱う。
1-3. レポート生成の材料（ドメイン的入力）
日次レポートを作るためには、最低限以下が揃っている必要がある：

Profile（ユーザー情報）

対象日のターゲット：

過去日 → DailyTargetSnapshot
当日 → Active Target
DailyNutritionSummary（数字としての実績）

その日の MealNutritionSummary 一覧（食事ごとの栄養）

（必要に応じて）直近数日の傾向を追加しても良いが、**基本は「その日 1 日分」**が対象

2. 外部仕様（UX / API 視点）
   2-1. 誰が・いつ使うか
   操作主体：ログイン済み + プロフィール設定済み + TRIAL/PAID のユーザー

主な使い方：

1 日のメイン食事回数分の記録が完了する（記録完了判定が true）
「今日のレポートを見る」ボタンを押す
→ 日次レポートが生成（なければ） / 取得（既にあれば）されて表示される
将来的には：

「履歴画面」で過去の日次レポート一覧を見れる
「直近 5 日分のレポート」が提案機能の前提になる
2-2. レポートに期待される UX
1 日の食事傾向を 自然言語で要約：

「タンパク質は目標に対して十分／不足」
「脂質が多め」「野菜が少なめ」など
行動につながる箇条書き：

good_points：やってよかったこと（継続したい習慣）
improvement_points：改善できるポイント
tomorrow_focus：明日やる具体的アクション
ユーザー視点では：

「栄養素の数字」ではなく **「今日はここが良くて、ここを変えるといい」**が一目で分かるもの。
2-3. API 仕様（外部インターフェース）
(1) POST /nutrition/daily/report
目的：指定日の日次レポートを「生成」する。

認証：必須

プラン制約：TRIAL / PAID のみ（FREE は 403/402）

リクエストボディ例：

{
"date": "2025-11-30"
}
前提条件：

対象日が 記録完了していること（DailyLogCompletion が true）
(user_id, date) の DailyNutritionReport がまだ存在しないこと
Profile が存在すること
栄養計算が可能なプラン（TRIAL / PAID）であること
振る舞い（ざっくり）：

ログインユーザー（user_id）を取得

プランチェック（TRIAL / PAID 以外ならエラー）

CheckDailyLogCompletionUseCase で is_completed を確認

false → DailyLogNotCompletedError → 400
既存レポート確認

既に存在 → DailyNutritionReportAlreadyExistsError → 409
Profile, TargetSnapshot/ActiveTarget, DailyNutritionSummary, MealNutritionSummary を揃える

LLM ポートを通してレポート生成

DailyNutritionReport として保存

レスポンスとしてレポート内容を返す

レスポンス例：

{
"date": "2025-11-30",
"summary": "今日はたんぱく質が目標を十分に満たしつつ、脂質を抑えたバランスの良い食事ができています。",
"good_points": [
"朝食・昼食・夕食それぞれでたんぱく質源を確保できています。",
"野菜や発酵食品から食物繊維やビタミンが取れています。"
],
"improvement_points": [
"やや炭水化物が多めなので、夕食の主食量を少し減らすとより良さそうです。"
],
"tomorrow_focus": [
"朝食でプロテインや卵など、たんぱく質を意識して取り入れる。",
"水分をこまめに摂りつつ、間食は 1 日 1 回までに抑える。"
]
}
(2) GET /nutrition/daily/report?date=YYYY-MM-DD
目的：既に生成済みの日次レポートを取得する。

認証：必須

プラン制約：

TRIAL / PAID：自由に取得可能
FREE：理屈の上では「過去に TRIAL / PAID の期間に生成されたレポート」を読むだけなら許可してもよい
（実装上は「作成禁止」で十分）
振る舞い：

Repo から (user_id, date) に対応する DailyNutritionReport を探す
見つからなければ 404
あればレポート内容をレスポンスとして返す
2-4. 他機能から見た「日次レポート外部仕様」
提案機能（MealRecommendation）は：

DailyNutritionReport を 直近 5 日分取得できることが前提。
生成済みのレポートを読み取り、LLM の入力として使用する。
UI 側：

「レポートタブ」や「履歴画面」で GET /nutrition/daily/report を叩いて表示する。
「今日のレポートが未生成」であれば、POST /nutrition/daily/report を叩いて生成 → 同時に表示する。 3. 内部仕様（ドメイン / UseCase / ポート）
3-1. ドメイン層
Entity: DailyNutritionReport
既に決めた通り：

DailyNutritionReport(
id: DailyNutritionReportId,
user_id: UserId,
date: date,
summary: str,
good_points: list[str],
improvement_points: list[str],
tomorrow_focus: list[str],
created_at: datetime,
)
不変条件：

(user_id, date) で高々 1 件。
生成後に中身を安易に書き換えない（再生成を許すなら専用 UC で扱う）。
主なエラー（ドメイン / アプリ層で利用）
DailyLogNotCompletedError
→ 記録が完了していないのにレポート生成しようとした場合。
DailyNutritionReportAlreadyExistsError
→ 既に同日のレポートが存在する場合。
3-2. Repository ポート
DailyNutritionReportRepositoryPort
class DailyNutritionReportRepositoryPort(Protocol):
def get_by_user_and_date(
self,
user_id: UserId,
target_date: date,
) -> DailyNutritionReport | None: ...

    def list_recent(
        self,
        user_id: UserId,
        limit: int,
    ) -> Sequence[DailyNutritionReport]: ...

    def save(self, report: DailyNutritionReport) -> None: ...

list_recent は提案機能で「直近 5 日分のレポート」を取得するときに使う。
3-3. LLM ポート（レポート生成）
DTO: DailyReportLLMInput / Output
@dataclass
class DailyReportLLMInput:
user_id: UserId
date: date
profile: Profile
target_snapshot: DailyTargetSnapshot # または当日の Active Target
daily_summary: DailyNutritionSummary
meal_summaries: list[MealNutritionSummary]

@dataclass
class DailyReportLLMOutput:
summary: str
good_points: list[str]
improvement_points: list[str]
tomorrow_focus: list[str]
Port: DailyNutritionReportGeneratorPort
class DailyNutritionReportGeneratorPort(Protocol):
def generate(self, input: DailyReportLLMInput) -> DailyReportLLMOutput:
...
実装：

StubDailyNutritionReportGenerator：固定文言 or 簡易ロジック
OpenAIDailyNutritionReportGenerator：OpenAI API による LLM 実装（将来）
3-4. UseCase：GenerateDailyNutritionReportUseCase
責務

(user_id, date) に対して「記録完了 → レポート生成可否を判定し、必要なら LLM を回して Report を生成・保存する」。
入力

user_id: UserId
date: date
依存（主なポート / UC）

CheckDailyLogCompletionUseCase
ProfileRepositoryPort
EnsureDailyTargetSnapshotUseCase（ターゲットスナップショットを用意する UC）
ComputeDailyNutritionSummaryUseCase
MealNutritionSummaryRepositoryPort
DailyNutritionReportRepositoryPort
DailyNutritionReportGeneratorPort（LLM）
ClockPort +（必要なら）プラン判定のための UserRepository / PlanChecker
処理フロー（論理）

プランチェック

User を取得し、plan in {TRIAL, PAID} であることを確認。
それ以外 → エラー（HTTP 層で 403/402）。
記録完了チェック

completion = CheckDailyLogCompletionUseCase.execute(user_id, date)
completion.is_completed が False → DailyLogNotCompletedError
既存レポート有無の確認

existing = report_repo.get_by_user_and_date(user_id, date)
existing があれば → DailyNutritionReportAlreadyExistsError
Profile 取得

profile_repo.get_by_user_id(user_id)
なければ → ProfileNotFound 的なエラー
ターゲット取得

EnsureDailyTargetSnapshotUseCase.execute(user_id, date) を呼ぶ：

過去日 → DailyTargetSnapshot
当日 → Active Target から Snapshot 的に扱う（実装次第）
戻り値を target_snapshot として LLM 入力に使う。

1 日分の栄養サマリ取得 / 再計算

daily = ComputeDailyNutritionSummaryUseCase.execute(user_id, date)
これにより、その日の DailyNutritionSummary が最新状態になる。
1 日ぶんの MealNutrition 一覧取得

meal_summaries = meal_nutrition_repo.list_by_user_and_date(user_id, date)
LLM 入力 DTO の組み立て & レポート生成

llm_input = DailyReportLLMInput(...)
llm_output = report_generator.generate(llm_input)
DailyNutritionReport エンティティを生成

created_at = clock.now()
DailyNutritionReport.create(...) で Entity を作る。
保存 & 戻り値

report_repo.save(report)
UseCase の戻り値として report を返す。
3-5. レポート取得 UseCase（補足）
GetDailyNutritionReportUseCase

execute(user_id, date) → Report or None
ListDailyNutritionReportsUseCase

execute(user_id, limit, from/to) → 最近 N 件など
API 側ではこれを叩いて GET /nutrition/daily/report や将来の一覧 API を提供する。

4. まとめ（日次レポートのキモ）
   何をしているか

「今日の食事ログ」と「栄養の数字」と「ターゲット」を材料に、
LLM を使って “1 日の栄養に関するフィードバック文章” を作って保存している。
いつ作れるか

記録完了（main の食事回数分が埋まっている）＋ TRIAL/PAID プランのときのみ。
同じ日には最大 1 回（再生成するなら別途ルールが必要）。
何に使われるか

ユーザー向けの振り返り画面
提案機能（直近 5 日分レポートを入力にする）
将来のバッジ（「レポートを ◯ 日連続で生成」など）
なぜ Daily で持つか

FoodEntry / Meal / Daily の「数字」だけだと伝わりづらいものを、
「言葉」で整理してあげる“意味のレイヤー”としての役割を担っている。
この仕様を前提にしておけば、
あとは LLM のプロンプト設計 や UI デザイン を乗せていくだけで、
かなりリッチな「1 日の振り返り体験」が作れるはずです 💡
