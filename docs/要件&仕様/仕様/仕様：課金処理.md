いいですね、ここまで土台が揃ってきたので、「課金処理」をちゃんと仕様にしておきましょう 💪
これまでと同じく：

概要
データ仕様（何を持つか）
外部仕様（UX / API）
内部仕様（ドメイン / UseCase / ポート / Webhook / 連携）
の流れで整理します。

課金処理（Billing / Stripe）の仕様 0. 概要
目的

ユーザーに対して 7 日間の無料トライアル → 有料プラン（Stripe） or 無料プラン という流れを提供し、
課金状況に応じて「使える機能」を制御する。
プランと機能制限の関係

プランは UserPlan として TRIAL / FREE / PAID の 3 種類：

TRIAL（試用期間中）

登録から 7 日間有効
有料と同じ機能が使える（栄養計算・日次レポート・提案機能）
PAID（有料）

Stripe でサブスク契約が「アクティブ」なユーザー
TRIAL と同じく全機能利用可能
FREE（無料）

trial 終了 ＋ Stripe 上の有効なサブスクなし

利用可能機能：

食事記録（FoodEntry）の CRUD
プロフィール編集
利用不可（もしくは制限される）機能：

栄養計算（Meal / Daily）
日次レポート生成
提案機能
Stripe の役割

決済・サブスクリプションの管理を担当。
バックエンド側は Stripe からの Webhook を受け取って
→ UserPlan や内部の Billing 状態を更新する。

1. データ仕様（ドメイン視点）
   1-1. User + Trial 情報（auth 側）
   既にある定義を前提とすると：

User(
id: UserId,
email: EmailAddress,
hashed_password: HashedPassword,
name: str,

    plan: UserPlan,        # "trial" / "free" / "paid"
    trial_info: TrialInfo, # trial_ends_at: datetime | None

    has_profile: bool,
    created_at: datetime,
    deleted_at: datetime | None,

)
新規登録時：

plan = TRIAL
trial_info.trial_ends_at = now + 7 days
trial が終了したかどうかは TrialInfo.is_trial_active で判定 (now < trial_ends_at)

1-2. Billing ドメイン（Stripe 連携情報）
BillingAccount（例）

BillingAccount(
id: BillingAccountId, # 内部用 ID（User 1:1 でも可）
user_id: UserId,

    stripe_customer_id: str,      # "cus_xxx"
    stripe_subscription_id: str | None, # "sub_xxx"
    subscription_status: BillingSubscriptionStatus,  # active / past_due / canceled / none

    current_plan: UserPlan,       # auth.User.plan と同期（冗長でもOK）
    updated_at: datetime,

)
BillingSubscriptionStatus 例：

NONE（サブスクなし）
ACTIVE
PAST_DUE
CANCELED
※ この Billing 情報を User に直接持たせるか、別テーブルに切るかは実装時の好みだが、DDD 的には domain/billing にコンテキストを切るのがきれい。

1-3. プラン状態の決定ロジック（概念）
最終的に「このユーザーは今 TRIAL / FREE / PAID のどれか？」を決めるためのルール：

trial_info.is_trial_active == True
→ 論理プランは TRIAL
trial が終了しており、Stripe 上の subscription_status が ACTIVE
→ 論理プランは PAID
上記どちらにも当てはまらない
→ FREE
→ これに基づき auth.User.plan を更新しておく（冗長でも可。plan を参照すれば早い）。

2. 外部仕様（UX / API 視点）
   2-1. ユーザーの課金フロー（UX）
   アカウント作成

自動的に 7 日間の TRIAL 開始。
課金ページ（Upgrade）

アプリ内の「アップグレード」ボタンを押すと、

Stripe Checkout へ遷移（サブスク購入用）
購入成功後：

Stripe → Webhook → バックエンド
バックエンド側で該当ユーザーを PAID に更新。
サブスクの管理

「プランを管理する」ボタンで Stripe Customer Portal へ遷移。

ユーザーはそこで：

サブスクのキャンセル
支払い方法の更新
などができる。
キャンセル後

Stripe 側でサブスクがキャンセルされ、期間終了後に canceled になる。
Webhook で通知を受けて User.plan = FREE へ。
TRIAL 終了

7 日経過すると trial_info.is_trial_active == False になる。
サブスクがなければ FREE に降格。
サブスクがあれば PAID として扱う。
2-2. API 仕様（外部インターフェース）
(1) POST /billing/checkout-session
目的：Stripe Checkout セッションを作成し、その URL をフロントに渡す。

認証：必須

入力：特になし（フロント側プランは 1 種類想定）

振る舞い：

User に対応する stripe_customer_id があるかチェック：

なければ Stripe 上で Customer を作成し、BillingAccount に保存。
Stripe の Checkout セッションを作成（サブスク用）。

セッション URL をレスポンスとして返す。

レスポンス例：

{
"checkout_url": "https://checkout.stripe.com/c/session_id"
}
(2) GET /billing/portal-url
目的：Stripe Customer Portal への URL を取得する。

認証：必須

振る舞い：

stripe_customer_id がなければエラー（BAD_REQUEST 相当）
Stripe の Billing Portal Session を作成
URL を返す
レスポンス例：

{
"portal_url": "https://billing.stripe.com/p/session_id"
}
(3) POST /billing/stripe/webhook
目的：Stripe からのイベント通知を受け取り、プラン状態を更新する。

認証：署名検証（Stripe の signing secret）で行う。

主に扱うイベント例：

checkout.session.completed

サブスク開始トリガー。
→ 該当ユーザーの stripe_subscription_id 登録
→ subscription_status = ACTIVE
→ User.plan = PAID
customer.subscription.created

customer.subscription.updated

status が active / past_due / canceled / unpaid 等に変わったときに BillingAccount / User.plan を更新。
customer.subscription.deleted

Webhook 仕様のポイント：

Stripe の署名検証を行う（イベント偽装防止）。
イベント ID (event.id) をログ or DB に保存し、同じ ID のイベントを二度処理しない（冪等性）。
レスポンス：

Stripe 推奨通り、正常時は 200 OK（ボディは {} 程度）。
署名検証失敗なら 400 / 401。
2-3. プラン判定に関する外部シグナル
/auth/me などで返すユーザー情報に以下を含める：

plan: "trial" / "free" / "paid"
trial_ends_at
これによってフロント側は：

「残り ◯ 日トライアルです」
「プランをアップグレードしましょう」
「現在のプラン：有料」
の表示を制御できる。

3. 内部仕様（ドメイン / UseCase / ポート / Webhook）
   3-1. Billing ドメイン（app/domain/billing のイメージ）
   Entity: BillingAccount
   前述の通り。

エラー例
StripeCustomerNotFoundError
StripeSubscriptionNotFoundError
BillingInconsistentStateError（Stripe と内部の状態が噛み合っていない等）
3-2. ポート（Application 層）
BillingRepositoryPort（BillingAccount 用）
class BillingRepositoryPort(Protocol):
def get_by_user_id(self, user_id: UserId) -> BillingAccount | None: ...
def save(self, account: BillingAccount) -> None: ...
StripeClientPort（Stripe への依存を抽象化）
class StripeClientPort(Protocol):
def create_customer(self, email: str, user_id: str) -> str: ...
def create_checkout_session(self, customer_id: str, success_url: str, cancel_url: str) -> str: ...
def create_billing_portal_session(self, customer_id: str, return_url: str) -> str: ...
def parse_event(self, payload: bytes, sig_header: str) -> StripeEvent: ... # 必要に応じて subscription の取得など
実装：

StripeClient（stripe-python を内部で利用）
3-3. UseCase 一覧
CreateCheckoutSessionUseCase
GetBillingPortalUrlUseCase
HandleStripeWebhookUseCase
UpdateUserPlanFromBillingUseCase（Webhook 内部または別 UC として）
3-4. 各 UseCase の仕様（ざっくり）
CreateCheckoutSessionUseCase
入力：user_id, success_url, cancel_url

フロー：

BillingAccount を取得（なければ作成）

StripeClient で customer を作成 → stripe_customer_id 保存
StripeClient.create_checkout_session を呼ぶ

返ってきた URL を返却

GetBillingPortalUrlUseCase
入力：user_id, return_url

フロー：

BillingAccount を取得
stripe_customer_id がなければエラー
StripeClient.create_billing_portal_session を呼ぶ
URL を返す
HandleStripeWebhookUseCase
入力：payload: bytes, signature_header: str

フロー：

StripeClient.parse_event で署名検証＋イベント解析

event.type ごとに処理分岐：

checkout.session.completed：

セッションから customer, subscription を取得

対応する user_id を特定（metadata or customer metadata）

BillingAccount を更新：

stripe_customer_id, stripe_subscription_id, subscription_status = ACTIVE
User.plan = PAID に更新（UserRepository 更新）

customer.subscription.updated / deleted：

subscription.status に応じて BillingAccount / User.plan を更新

active → plan = PAID

canceled / unpaid / past_due の場合：

trial も expired → plan = FREE
イベント ID をログ or DB に保存し、二重処理を防ぐ

3-5. プランチェックの組み込み
栄養計算 / 日次レポート / 提案などの UseCase で、

User.plan と trial_info を見て「この機能を実行して良いか」を判定する。
例：ComputeMealNutritionUseCase 冒頭：

user = user_repo.get_by_id(user_id)
if not is_feature_available("nutrition", user):
raise PermissionDeniedError("Nutrition features require trial or paid plan.")
is_feature_available のロジック（擬似）：

def is_feature_available(feature: str, user: User) -> bool: # trial 中は有料機能を全て解放
if user.trial_info.is_trial_active:
return True # trial 終了後は plan == PAID のみ
if user.plan == UserPlan.PAID:
return True
return False 4. まとめ（課金処理仕様のキモ）
Stripe は「決済・サブスク情報のソース・オブ・トゥルース」
→ こちらは Stripe Webhook を受けて内部の Billing / User.plan を更新する。

アプリ側の論理プラン（TRIAL / FREE / PAID）は User に閉じておく
→ 機能制御は User.plan + TrialInfo を見るだけで判定可能。

MVP としての範囲

7 日間の TRIAL を Auth で付与（登録時）
Stripe Checkout + Billing Portal を使った 単一プランのサブスク
Webhook による PAID / FREE への状態遷移
「栄養計算 / 日次レポート / 提案」は TRIAL / PAID のみに制限する
この仕様を前提に、
domain/billing, application/billing, infra/billing/stripe, api/http/billing_route.py を
いつもの DDD/クリーンアーキ構造に乗せていけば、そのまま実装にスライドできるはずです 💡
