いいですね、じゃあ今回は 記録完了判定（DailyLogCompletion）だけ にフォーカスして、
これまでと同じノリで

概要
データ仕様（何を見て何を返すか）
外部仕様（UX / API としてどう扱うか）
内部仕様（ドメイン / UseCase / Repo / 他機能との関係）
を整理していきます 💪

記録完了判定（DailyLogCompletion）の仕様 0. 概要
目的

「その日、その人は『必要な回数の食事ログ』をちゃんと記録し終えているか？」を判定する。

判定結果は：

日次レポート生成可否
提案機能の前提
将来的なバッジ（連続記録・達成報酬）のトリガー
に使われる。
対象

ある (user_id, date) のペアに対して
→ 「記録完了（completed）かどうか」を判断する。

1. データ仕様（何を見て何を返すか）
   1-1. 前提となるデータ
   Profile
   user_id

meals_per_day: int （1 日あたりのメイン食事回数）

例：2 / 3 / 4
1 <= meals_per_day であることが必須（0 や負数はエラー）
FoodEntry
user_id

date

meal_type: "main" | "snack"

meal_index: int | None

main のとき：1..meals_per_day
snack のとき：None
deleted_at: datetime | None（ソフトデリート）

deleted_at is not None のものは記録完了判定の対象外
1-2. 記録完了の定義（ビジネスルール）
ある (user_id, date) に対して：

Profile が存在し、meals_per_day = N (>=1) が設定されていること。

その日の FoodEntry のうち、

meal_type == "main"
deleted_at is None
の meal_index を集める。
集合 {1, 2, ..., N} が すべて含まれているなら記録完了。

→ これを満たせばその日は 「記録完了（completed）」。
snack (meal_type == "snack") は完了判定には関与しない。

1-3. 判定結果としての情報
DailyLogCompletionResult（論理的 DTO）

user_id: UserId

date: date

meals_per_day: int

is_completed: bool

filled_indices: list[int]

記録済みの main meal_index（例：[1, 2]）
missing_indices: list[int]

まだ記録されていない main meal_index（例：[3]）
例：

meals_per_day = 3
その日の main 食事が meal_index = 1, 3 のみ
→ is_completed = False
→ filled_indices = [1, 3]
→ missing_indices = [2]

1-4. エラーとして扱うケース
Profile が存在しない場合：

「記録完了」を判定する前提がないため、エラーとする
（例：DailyLogProfileNotFoundError）
meals_per_day < 1 の場合：

無効な設定として、エラーとする
（例：InvalidMealsPerDayError）
「とりあえず 3 回扱いにして判定…」のようなデフォルトは取らず、
Profile 未設定の状態では上位機能（日次レポート・提案なども利用不可）という前提にする。

2. 外部仕様（UX / API 視点）
   2-1. 誰が・いつ使うか
   主に サーバー内部のロジック から利用する判定（UseCase）だが、

将来的には以下のような UI 要素にも活用したい：

日次の進捗表示

1 日の記録状況を「○/N 食記録済み」と表示。
例：「3 回中 2 回記録済み（残り：3 回目）」。
レポートボタンの活性 / 非活性

is_completed == true の日だけ「今日のレポートを生成」ボタンを有効にする。
未完了なら「あと 1 食記録するとレポートが作成できます」のような表示。
連続記録・バッジ表示

「連続 ◯ 日記録完了」バッジなどの判定に利用。
2-2. API を公開するかどうか
現時点では 内部 UC として使う前提 だが、
UI から直接見たい場合は例えば以下のようなエンドポイントもあり得る：

GET /daily/log/status?date=YYYY-MM-DD
認証：必須

機能：

(user_id, date) について is_completed / missing_indices などを返す。
レスポンス例：

{
"date": "2025-11-30",
"meals_per_day": 3,
"is_completed": false,
"filled_indices": [1, 3],
"missing_indices": [2]
}
※ 必須ではないが、
「ホーム画面に今日の進捗を出したい」などのときに便利。

2-3. 他機能から見た「外部仕様」
日次レポート生成（DailyNutritionReport）

対象日が is_completed == true でなければ生成不可。
例：DailyLogNotCompletedError を発生させる。
提案機能（MealRecommendation）

直近 5 日分のレポートを生成する前提として、
各日が記録完了している必要がある（＝レポートが存在する前提）。
バッジ / 報酬

「記録完了した日」をカウント or 連続数計算するときの根拠に使う。 3. 内部仕様（ドメイン / UseCase / Repo）
3-1. ドメイン層（app/domain/meal / app/domain/profile）
Profile：

meals_per_day の制約（1 以上）
FoodEntry：

meal_type / meal_index の関係を正しく維持（main に対して 1..N）
ドメインエラー：

DailyLogProfileNotFoundError（Profile 未設定）
InvalidMealsPerDayError
※ 記録完了自体は「ドメインサービス」寄りだが、
実装上は アプリケーション層の UseCase に寄せる方針で OK。

3-2. Repository ポート
ProfileRepositoryPort
class ProfileRepositoryPort(Protocol):
def get*by_user_id(self, user_id: UserId) -> Profile | None: ...
FoodEntryRepositoryPort（既存）
class FoodEntryRepositoryPort(Protocol):
def list_by_user_and_date(
self, user_id: UserId, date*: date
) -> list[FoodEntry]: ...
list_by_user_and_date は deleted_at is None のみを返す前提。
3-3. UseCase：CheckDailyLogCompletionUseCase
責務

(user_id, date) に対して、
「その日のメイン食事が meals_per_day 回分すべて記録されているか」を判定する。
インターフェース（論理）

class CheckDailyLogCompletionUseCase:
def **init**(
self,
profile_repo: ProfileRepositoryPort,
food_entry_repo: FoodEntryRepositoryPort,
): ...

    def execute(self, user_id: UserId, date: date) -> DailyLogCompletionResultDTO:
        ...

処理フロー

Profile 取得

profile = profile_repo.get_by_user_id(user_id)
未取得 → DailyLogProfileNotFoundError を投げる
meals_per_day = profile.meals_per_day

meals_per_day < 1 → InvalidMealsPerDayError
FoodEntry 一覧取得

entries = food_entry_repo.list_by_user_and_date(user_id, date)
deleted_at is None のもののみが返る前提
main エントリだけを抽出

meal_type == "main" のもののみ対象
meal_index が None / 範囲外の場合はスキップ or バグ検知（実装方針次第）
その日の main のインデックス集合を作成

main_indices = {e.meal_index for e in main_entries}
必要なインデックス集合を作成

required = {1, 2, ..., meals_per_day}
missing_indices = sorted(required - main_indices)

filled_indices = sorted(main_indices & required)
is_completed = len(missing_indices) == 0
DailyLogCompletionResultDTO として返す：

DailyLogCompletionResultDTO(
user_id=user_id,
date=date,
meals_per_day=meals_per_day,
is_completed=is_completed,
filled_indices=filled_indices,
missing_indices=missing_indices,
)
3-4. 上位 UseCase での利用例
日次レポート生成 UC
completion = check_daily_log_completion_uc.execute(user_id, date)
if not completion.is_completed:
raise DailyLogNotCompletedError(
f"Daily log not completed. missing={completion.missing_indices}"
)

# → ここで初めて DailyNutritionReport の生成に進む

バッジ判定 UC（将来的な例）
result = check_daily_log_completion_uc.execute(user_id, date)
if result.is_completed: # 連続日数カウント / バッジ付与ロジックへ 4. まとめ（記録完了判定のキモ）
何をしているか：

Profile.meals_per_day と、当日の main FoodEntry の有無だけを見て
「その日に必要なメイン食事回数分が、ちゃんと記録されているか」を判定する。
どう使われるか：

日次レポート生成の前提チェック
提案機能の前段（＝レポートが揃っているかどうか）
将来のバッジ・連続記録などのトリガー
なぜ分離しているか：

栄養計算（Meal/Daily の数値）とは独立した概念として
「ユーザーが行動として記録を完了しているか」を見るため。
→ 食事内容の質ではなく、「記録の行動」を評価する軸。
この仕様を前提にしておけば、
あとは「DailyLogCompletionUseCase の実装」と「各 UC からの呼び出し」を揃えるだけで、
レポート・提案・バッジに一貫した「完了判定の土台」を提供できるようになります 💡
